"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@visactor+vgrammar-wordcloud-shape@0.14.13";
exports.ids = ["vendor-chunks/@visactor+vgrammar-wordcloud-shape@0.14.13"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/cloud-shape-layout.js":
/*!************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/cloud-shape-layout.js ***!
  \************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _segmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./segmentation */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/segmentation.js\");\n/* harmony import */ var _wordle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wordle */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/wordle.js\");\n/* harmony import */ var _filling__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filling */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/filling.js\");\n\n\n\n\n\n\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(words, layoutConfig, segmentationOutput) {\n    (0,_segmentation__WEBPACK_IMPORTED_MODULE_0__.allocateWords)(words, segmentationOutput), \"ensureMapping\" === layoutConfig.layoutMode ? (0,_wordle__WEBPACK_IMPORTED_MODULE_1__.layoutGlobalShrink)(words, layoutConfig, segmentationOutput) : \"ensureMappingEnlarge\" === layoutConfig.layoutMode ? (0,_wordle__WEBPACK_IMPORTED_MODULE_1__.layoutSelfEnlarge)(words, layoutConfig, segmentationOutput) : (0,_wordle__WEBPACK_IMPORTED_MODULE_1__.layout)(words, layoutConfig, segmentationOutput);\n    const fillingWords = (0,_filling__WEBPACK_IMPORTED_MODULE_2__.filling)(words, layoutConfig, segmentationOutput), failedWords = [], successedWords = [];\n    for (let i = 0; i < words.length; i++) words[i].hasPlaced ? successedWords.push(words[i]) : failedWords.push(words[i]);\n    return failedWords.forEach((word => word.visible = !1)), {\n        fillingWords: fillingWords,\n        successedWords: successedWords,\n        failedWords: failedWords\n    };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZUAwLjE0LjEzL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItd29yZGNsb3VkLXNoYXBlL2VzL2Nsb3VkLXNoYXBlLWxheW91dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQStDOztBQUUwQjs7QUFFckM7O0FBRXBDLDZCQUFlLG9DQUFTO0FBQ3hCLElBQUksNERBQWEsMkVBQTJFLDJEQUFrQixpR0FBaUcsMERBQWlCLDRDQUE0QywrQ0FBTTtBQUNsUix5QkFBeUIsaURBQU87QUFDaEMsb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9meW5sYXRpY3MtYWkvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZUAwLjE0LjEzL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItd29yZGNsb3VkLXNoYXBlL2VzL2Nsb3VkLXNoYXBlLWxheW91dC5qcz9lNzIxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFsbG9jYXRlV29yZHMgfSBmcm9tIFwiLi9zZWdtZW50YXRpb25cIjtcblxuaW1wb3J0IHsgbGF5b3V0LCBsYXlvdXRHbG9iYWxTaHJpbmssIGxheW91dFNlbGZFbmxhcmdlIH0gZnJvbSBcIi4vd29yZGxlXCI7XG5cbmltcG9ydCB7IGZpbGxpbmcgfSBmcm9tIFwiLi9maWxsaW5nXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHdvcmRzLCBsYXlvdXRDb25maWcsIHNlZ21lbnRhdGlvbk91dHB1dCkge1xuICAgIGFsbG9jYXRlV29yZHMod29yZHMsIHNlZ21lbnRhdGlvbk91dHB1dCksIFwiZW5zdXJlTWFwcGluZ1wiID09PSBsYXlvdXRDb25maWcubGF5b3V0TW9kZSA/IGxheW91dEdsb2JhbFNocmluayh3b3JkcywgbGF5b3V0Q29uZmlnLCBzZWdtZW50YXRpb25PdXRwdXQpIDogXCJlbnN1cmVNYXBwaW5nRW5sYXJnZVwiID09PSBsYXlvdXRDb25maWcubGF5b3V0TW9kZSA/IGxheW91dFNlbGZFbmxhcmdlKHdvcmRzLCBsYXlvdXRDb25maWcsIHNlZ21lbnRhdGlvbk91dHB1dCkgOiBsYXlvdXQod29yZHMsIGxheW91dENvbmZpZywgc2VnbWVudGF0aW9uT3V0cHV0KTtcbiAgICBjb25zdCBmaWxsaW5nV29yZHMgPSBmaWxsaW5nKHdvcmRzLCBsYXlvdXRDb25maWcsIHNlZ21lbnRhdGlvbk91dHB1dCksIGZhaWxlZFdvcmRzID0gW10sIHN1Y2Nlc3NlZFdvcmRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7IGkrKykgd29yZHNbaV0uaGFzUGxhY2VkID8gc3VjY2Vzc2VkV29yZHMucHVzaCh3b3Jkc1tpXSkgOiBmYWlsZWRXb3Jkcy5wdXNoKHdvcmRzW2ldKTtcbiAgICByZXR1cm4gZmFpbGVkV29yZHMuZm9yRWFjaCgod29yZCA9PiB3b3JkLnZpc2libGUgPSAhMSkpLCB7XG4gICAgICAgIGZpbGxpbmdXb3JkczogZmlsbGluZ1dvcmRzLFxuICAgICAgICBzdWNjZXNzZWRXb3Jkczogc3VjY2Vzc2VkV29yZHMsXG4gICAgICAgIGZhaWxlZFdvcmRzOiBmYWlsZWRXb3Jkc1xuICAgIH07XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/cloud-shape-layout.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/filling.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/filling.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   filling: () => (/* binding */ filling)\n/* harmony export */ });\n/* harmony import */ var _wordle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wordle */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/wordle.js\");\n\n\nfunction filling(words, layoutConfig, segmentationOutput) {\n    const {size: size, fillingTimes: fillingTimes, fillingXStep: fillingXStep, fillingYStep: fillingYStep, getFillingFontStyle: getFillingFontStyle, getFillingFontWeight: getFillingFontWeight, getFillingFontFamily: getFillingFontFamily, fillingInitialFontSize: fillingInitialFontSize, fillingDeltaFontSize: fillingDeltaFontSize, fillingInitialOpacity: fillingInitialOpacity, fillingDeltaOpacity: fillingDeltaOpacity, fillingRotateList: fillingRotateList, getFillingPadding: getFillingPadding, random: random, board: board, minFillFontSize: minFillFontSize} = layoutConfig, {boardSize: boardSize, shapeBounds: shapeBounds, tempCanvas: canvas, randomGenerator: randomGenerator} = segmentationOutput, ctx = canvas.getContext(\"2d\", {\n        willReadFrequently: !0\n    });\n    let fontSize = fillingInitialFontSize, opacity = fillingInitialOpacity;\n    const placedFillingWords = [];\n    for (let i = 0; i < fillingTimes; i++) filling1Time(fontSize, opacity), fontSize = Math.max(fontSize > fillingDeltaFontSize ? fontSize - fillingDeltaFontSize : fillingDeltaFontSize, minFillFontSize), \n    opacity = opacity > fillingDeltaOpacity ? opacity - fillingDeltaOpacity : fillingDeltaOpacity;\n    return placedFillingWords;\n    function filling1Time(fontSize, opacity) {\n        const fillingWords = words.map((word => {\n            const {text: text, color: color, fillingColor: fillingColor, hasPlaced: hasPlaced, datum: datum} = word;\n            return {\n                x: 0,\n                y: 0,\n                weight: 0,\n                text: text,\n                fontFamily: getFillingFontFamily(datum),\n                fontStyle: getFillingFontStyle(datum),\n                fontWeight: getFillingFontWeight(datum),\n                fontSize: fontSize,\n                rotate: fillingRotateList[~~(randomGenerator() * fillingRotateList.length)],\n                padding: getFillingPadding(datum),\n                opacity: opacity,\n                visible: !0,\n                color: color,\n                fillingColor: fillingColor,\n                hasPlaced: hasPlaced,\n                datum: datum\n            };\n        }));\n        randomArray(fillingWords);\n        let wi = 0;\n        const {x1: x1, y1: y1, x2: x2, y2: y2} = shapeBounds, [startX, startY] = [ x1 + ~~(randomGenerator() * fillingXStep * 2), y1 + ~~(randomGenerator() * fillingYStep * 2) ];\n        for (let y = startY; y <= y2; y += fillingYStep) for (let x = startX; x <= x2; x += fillingXStep) {\n            (0,_wordle__WEBPACK_IMPORTED_MODULE_0__.measureSprite)(canvas, ctx, fillingWords, wi);\n            const word = fillingWords[wi];\n            word.x = x, word.y = y;\n            const {wordSize: wordSize, bounds: bounds, hasPlaced: hasPlaced} = word;\n            if (!hasPlaced || !bounds) {\n                ++wi === fillingWords.length && (wi = 0, random && randomArray(fillingWords));\n                continue;\n            }\n            const {dTop: dTop, dBottom: dBottom, dLeft: dLeft, dRight: dRight} = bounds;\n            word.x - dLeft < 0 || word.x + dRight > size[0] || word.y - dTop < 0 || word.y + dBottom > size[1] || word.hasText && word.sprite && !(0,_wordle__WEBPACK_IMPORTED_MODULE_0__.isCollideWithBoard)(word, board, boardSize) && ((0,_wordle__WEBPACK_IMPORTED_MODULE_0__.placeWordOnBoard)(word, board, boardSize), \n            placedFillingWords.push(Object.assign({}, word)), ++wi === fillingWords.length && (wi = 0, \n            random && randomArray(fillingWords)));\n        }\n    }\n    function randomArray(words) {\n        return words.sort((() => randomGenerator() - .5));\n    }\n}\n//# sourceMappingURL=filling.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZUAwLjE0LjEzL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItd29yZGNsb3VkLXNoYXBlL2VzL2ZpbGxpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0U7O0FBRXhFO0FBQ1AsV0FBVyxraUJBQWtpQixpQkFBaUIsc0dBQXNHO0FBQ3BxQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwRkFBMEY7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLGdDQUFnQztBQUMvQyw2QkFBNkIsU0FBUyx3Q0FBd0MsU0FBUztBQUN2RixZQUFZLHNEQUFhO0FBQ3pCO0FBQ0E7QUFDQSxtQkFBbUIsMERBQTBEO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDREQUE0RDtBQUMvRSxrSkFBa0osMkRBQWtCLDZCQUE2Qix5REFBZ0I7QUFDak4sb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9meW5sYXRpY3MtYWkvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZUAwLjE0LjEzL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItd29yZGNsb3VkLXNoYXBlL2VzL2ZpbGxpbmcuanM/NDQyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtZWFzdXJlU3ByaXRlLCBpc0NvbGxpZGVXaXRoQm9hcmQsIHBsYWNlV29yZE9uQm9hcmQgfSBmcm9tIFwiLi93b3JkbGVcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbGxpbmcod29yZHMsIGxheW91dENvbmZpZywgc2VnbWVudGF0aW9uT3V0cHV0KSB7XG4gICAgY29uc3Qge3NpemU6IHNpemUsIGZpbGxpbmdUaW1lczogZmlsbGluZ1RpbWVzLCBmaWxsaW5nWFN0ZXA6IGZpbGxpbmdYU3RlcCwgZmlsbGluZ1lTdGVwOiBmaWxsaW5nWVN0ZXAsIGdldEZpbGxpbmdGb250U3R5bGU6IGdldEZpbGxpbmdGb250U3R5bGUsIGdldEZpbGxpbmdGb250V2VpZ2h0OiBnZXRGaWxsaW5nRm9udFdlaWdodCwgZ2V0RmlsbGluZ0ZvbnRGYW1pbHk6IGdldEZpbGxpbmdGb250RmFtaWx5LCBmaWxsaW5nSW5pdGlhbEZvbnRTaXplOiBmaWxsaW5nSW5pdGlhbEZvbnRTaXplLCBmaWxsaW5nRGVsdGFGb250U2l6ZTogZmlsbGluZ0RlbHRhRm9udFNpemUsIGZpbGxpbmdJbml0aWFsT3BhY2l0eTogZmlsbGluZ0luaXRpYWxPcGFjaXR5LCBmaWxsaW5nRGVsdGFPcGFjaXR5OiBmaWxsaW5nRGVsdGFPcGFjaXR5LCBmaWxsaW5nUm90YXRlTGlzdDogZmlsbGluZ1JvdGF0ZUxpc3QsIGdldEZpbGxpbmdQYWRkaW5nOiBnZXRGaWxsaW5nUGFkZGluZywgcmFuZG9tOiByYW5kb20sIGJvYXJkOiBib2FyZCwgbWluRmlsbEZvbnRTaXplOiBtaW5GaWxsRm9udFNpemV9ID0gbGF5b3V0Q29uZmlnLCB7Ym9hcmRTaXplOiBib2FyZFNpemUsIHNoYXBlQm91bmRzOiBzaGFwZUJvdW5kcywgdGVtcENhbnZhczogY2FudmFzLCByYW5kb21HZW5lcmF0b3I6IHJhbmRvbUdlbmVyYXRvcn0gPSBzZWdtZW50YXRpb25PdXRwdXQsIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6ICEwXG4gICAgfSk7XG4gICAgbGV0IGZvbnRTaXplID0gZmlsbGluZ0luaXRpYWxGb250U2l6ZSwgb3BhY2l0eSA9IGZpbGxpbmdJbml0aWFsT3BhY2l0eTtcbiAgICBjb25zdCBwbGFjZWRGaWxsaW5nV29yZHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGxpbmdUaW1lczsgaSsrKSBmaWxsaW5nMVRpbWUoZm9udFNpemUsIG9wYWNpdHkpLCBmb250U2l6ZSA9IE1hdGgubWF4KGZvbnRTaXplID4gZmlsbGluZ0RlbHRhRm9udFNpemUgPyBmb250U2l6ZSAtIGZpbGxpbmdEZWx0YUZvbnRTaXplIDogZmlsbGluZ0RlbHRhRm9udFNpemUsIG1pbkZpbGxGb250U2l6ZSksIFxuICAgIG9wYWNpdHkgPSBvcGFjaXR5ID4gZmlsbGluZ0RlbHRhT3BhY2l0eSA/IG9wYWNpdHkgLSBmaWxsaW5nRGVsdGFPcGFjaXR5IDogZmlsbGluZ0RlbHRhT3BhY2l0eTtcbiAgICByZXR1cm4gcGxhY2VkRmlsbGluZ1dvcmRzO1xuICAgIGZ1bmN0aW9uIGZpbGxpbmcxVGltZShmb250U2l6ZSwgb3BhY2l0eSkge1xuICAgICAgICBjb25zdCBmaWxsaW5nV29yZHMgPSB3b3Jkcy5tYXAoKHdvcmQgPT4ge1xuICAgICAgICAgICAgY29uc3Qge3RleHQ6IHRleHQsIGNvbG9yOiBjb2xvciwgZmlsbGluZ0NvbG9yOiBmaWxsaW5nQ29sb3IsIGhhc1BsYWNlZDogaGFzUGxhY2VkLCBkYXR1bTogZGF0dW19ID0gd29yZDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgIHdlaWdodDogMCxcbiAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IGdldEZpbGxpbmdGb250RmFtaWx5KGRhdHVtKSxcbiAgICAgICAgICAgICAgICBmb250U3R5bGU6IGdldEZpbGxpbmdGb250U3R5bGUoZGF0dW0pLFxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IGdldEZpbGxpbmdGb250V2VpZ2h0KGRhdHVtKSxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogZm9udFNpemUsXG4gICAgICAgICAgICAgICAgcm90YXRlOiBmaWxsaW5nUm90YXRlTGlzdFt+fihyYW5kb21HZW5lcmF0b3IoKSAqIGZpbGxpbmdSb3RhdGVMaXN0Lmxlbmd0aCldLFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IGdldEZpbGxpbmdQYWRkaW5nKGRhdHVtKSxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiBvcGFjaXR5LFxuICAgICAgICAgICAgICAgIHZpc2libGU6ICEwLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICBmaWxsaW5nQ29sb3I6IGZpbGxpbmdDb2xvcixcbiAgICAgICAgICAgICAgICBoYXNQbGFjZWQ6IGhhc1BsYWNlZCxcbiAgICAgICAgICAgICAgICBkYXR1bTogZGF0dW1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmFuZG9tQXJyYXkoZmlsbGluZ1dvcmRzKTtcbiAgICAgICAgbGV0IHdpID0gMDtcbiAgICAgICAgY29uc3Qge3gxOiB4MSwgeTE6IHkxLCB4MjogeDIsIHkyOiB5Mn0gPSBzaGFwZUJvdW5kcywgW3N0YXJ0WCwgc3RhcnRZXSA9IFsgeDEgKyB+fihyYW5kb21HZW5lcmF0b3IoKSAqIGZpbGxpbmdYU3RlcCAqIDIpLCB5MSArIH5+KHJhbmRvbUdlbmVyYXRvcigpICogZmlsbGluZ1lTdGVwICogMikgXTtcbiAgICAgICAgZm9yIChsZXQgeSA9IHN0YXJ0WTsgeSA8PSB5MjsgeSArPSBmaWxsaW5nWVN0ZXApIGZvciAobGV0IHggPSBzdGFydFg7IHggPD0geDI7IHggKz0gZmlsbGluZ1hTdGVwKSB7XG4gICAgICAgICAgICBtZWFzdXJlU3ByaXRlKGNhbnZhcywgY3R4LCBmaWxsaW5nV29yZHMsIHdpKTtcbiAgICAgICAgICAgIGNvbnN0IHdvcmQgPSBmaWxsaW5nV29yZHNbd2ldO1xuICAgICAgICAgICAgd29yZC54ID0geCwgd29yZC55ID0geTtcbiAgICAgICAgICAgIGNvbnN0IHt3b3JkU2l6ZTogd29yZFNpemUsIGJvdW5kczogYm91bmRzLCBoYXNQbGFjZWQ6IGhhc1BsYWNlZH0gPSB3b3JkO1xuICAgICAgICAgICAgaWYgKCFoYXNQbGFjZWQgfHwgIWJvdW5kcykge1xuICAgICAgICAgICAgICAgICsrd2kgPT09IGZpbGxpbmdXb3Jkcy5sZW5ndGggJiYgKHdpID0gMCwgcmFuZG9tICYmIHJhbmRvbUFycmF5KGZpbGxpbmdXb3JkcykpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qge2RUb3A6IGRUb3AsIGRCb3R0b206IGRCb3R0b20sIGRMZWZ0OiBkTGVmdCwgZFJpZ2h0OiBkUmlnaHR9ID0gYm91bmRzO1xuICAgICAgICAgICAgd29yZC54IC0gZExlZnQgPCAwIHx8IHdvcmQueCArIGRSaWdodCA+IHNpemVbMF0gfHwgd29yZC55IC0gZFRvcCA8IDAgfHwgd29yZC55ICsgZEJvdHRvbSA+IHNpemVbMV0gfHwgd29yZC5oYXNUZXh0ICYmIHdvcmQuc3ByaXRlICYmICFpc0NvbGxpZGVXaXRoQm9hcmQod29yZCwgYm9hcmQsIGJvYXJkU2l6ZSkgJiYgKHBsYWNlV29yZE9uQm9hcmQod29yZCwgYm9hcmQsIGJvYXJkU2l6ZSksIFxuICAgICAgICAgICAgcGxhY2VkRmlsbGluZ1dvcmRzLnB1c2goT2JqZWN0LmFzc2lnbih7fSwgd29yZCkpLCArK3dpID09PSBmaWxsaW5nV29yZHMubGVuZ3RoICYmICh3aSA9IDAsIFxuICAgICAgICAgICAgcmFuZG9tICYmIHJhbmRvbUFycmF5KGZpbGxpbmdXb3JkcykpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByYW5kb21BcnJheSh3b3Jkcykge1xuICAgICAgICByZXR1cm4gd29yZHMuc29ydCgoKCkgPT4gcmFuZG9tR2VuZXJhdG9yKCkgLSAuNSkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbGxpbmcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/filling.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/index.js":
/*!***********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/index.js ***!
  \***********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WORDCLOUD_SHAPE_HOOK_EVENT: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_0__.WORDCLOUD_SHAPE_HOOK_EVENT),\n/* harmony export */   registerWordCloudShapeTransforms: () => (/* binding */ registerWordCloudShapeTransforms)\n/* harmony export */ });\n/* harmony import */ var _visactor_vgrammar_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @visactor/vgrammar-core */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-core@0.14.13/node_modules/@visactor/vgrammar-core/es/core/factory.js\");\n/* harmony import */ var _wordcloud_shape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wordcloud-shape */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/wordcloud-shape.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/util.js\");\n\n\n\n\n\n\nconst registerWordCloudShapeTransforms = () => {\n    _visactor_vgrammar_core__WEBPACK_IMPORTED_MODULE_1__.Factory.registerTransform(\"wordcloudShape\", {\n        transform: _wordcloud_shape__WEBPACK_IMPORTED_MODULE_2__.transform,\n        markPhase: \"beforeJoin\"\n    }, !0);\n};\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZUAwLjE0LjEzL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItd29yZGNsb3VkLXNoYXBlL2VzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWtEOztBQUVKOztBQUVNOztBQUU3QztBQUNQLElBQUksNERBQU87QUFDWCxtQkFBbUIsdURBQVM7QUFDNUI7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Z5bmxhdGljcy1haS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdmlzYWN0b3IrdmdyYW1tYXItd29yZGNsb3VkLXNoYXBlQDAuMTQuMTMvbm9kZV9tb2R1bGVzL0B2aXNhY3Rvci92Z3JhbW1hci13b3JkY2xvdWQtc2hhcGUvZXMvaW5kZXguanM/MzFjNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBGYWN0b3J5IH0gZnJvbSBcIkB2aXNhY3Rvci92Z3JhbW1hci1jb3JlXCI7XG5cbmltcG9ydCB7IHRyYW5zZm9ybSB9IGZyb20gXCIuL3dvcmRjbG91ZC1zaGFwZVwiO1xuXG5leHBvcnQgeyBXT1JEQ0xPVURfU0hBUEVfSE9PS19FVkVOVCB9IGZyb20gXCIuL3V0aWxcIjtcblxuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyV29yZENsb3VkU2hhcGVUcmFuc2Zvcm1zID0gKCkgPT4ge1xuICAgIEZhY3RvcnkucmVnaXN0ZXJUcmFuc2Zvcm0oXCJ3b3JkY2xvdWRTaGFwZVwiLCB7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgICBtYXJrUGhhc2U6IFwiYmVmb3JlSm9pblwiXG4gICAgfSwgITApO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/layout.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/layout.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Layout: () => (/* binding */ Layout)\n/* harmony export */ });\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.18.18/node_modules/@visactor/vutils/es/common/isString.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.18.18/node_modules/@visactor/vutils/es/common/array.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.18.18/node_modules/@visactor/vutils/es/angle.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.18.18/node_modules/@visactor/vutils/es/common/isFunction.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.18.18/node_modules/@visactor/vutils/es/common/toNumber.js\");\n/* harmony import */ var _segmentation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./segmentation */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/segmentation.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/util.js\");\n/* harmony import */ var _visactor_vscale__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @visactor/vscale */ \"(ssr)/./node_modules/.pnpm/@visactor+vscale@0.18.18/node_modules/@visactor/vscale/es/ordinal-scale.js\");\n/* harmony import */ var _visactor_vscale__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @visactor/vscale */ \"(ssr)/./node_modules/.pnpm/@visactor+vscale@0.18.18/node_modules/@visactor/vscale/es/linear-scale.js\");\n/* harmony import */ var _visactor_vscale__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @visactor/vscale */ \"(ssr)/./node_modules/.pnpm/@visactor+vscale@0.18.18/node_modules/@visactor/vscale/es/sqrt-scale.js\");\n/* harmony import */ var _cloud_shape_layout__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cloud-shape-layout */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/cloud-shape-layout.js\");\n/* harmony import */ var _visactor_vrender_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @visactor/vrender-core */ \"(ssr)/./node_modules/.pnpm/@visactor+vrender-core@0.20.12/node_modules/@visactor/vrender-core/es/modules.js\");\n/* harmony import */ var _visactor_vgrammar_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @visactor/vgrammar-util */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-util@0.14.13/node_modules/@visactor/vgrammar-util/es/image.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst OUTPUT = {\n    x: \"x\",\n    y: \"y\",\n    fontFamily: \"fontFamily\",\n    fontSize: \"fontSize\",\n    fontStyle: \"fontStyle\",\n    fontWeight: \"fontWeight\",\n    angle: \"angle\",\n    opacity: \"opacity\",\n    visible: \"visible\",\n    isFillingWord: \"isFillingWord\",\n    color: \"color\"\n};\n\nclass Layout {\n    constructor(options, view) {\n        this.progressiveResult = [], this.options = options, this.view = view;\n    }\n    layout(data) {\n        this.data = data;\n        const options = this.options, segmentationInput = {\n            shapeUrl: options.shape,\n            size: options.size,\n            ratio: options.ratio || .8,\n            tempCanvas: void 0,\n            boardSize: [ 0, 0 ],\n            random: !1,\n            randomGenerator: void 0\n        }, tempCanvas = _visactor_vrender_core__WEBPACK_IMPORTED_MODULE_0__.vglobal.createCanvas({\n            width: options.size[0],\n            height: options.size[1]\n        }), tempCtx = tempCanvas.getContext(\"2d\", {\n            willReadFrequently: !0\n        });\n        tempCtx.textAlign = \"center\", tempCtx.textBaseline = \"middle\", segmentationInput.tempCanvas = tempCanvas;\n        const boardW = options.size[0] + 31 >> 5 << 5;\n        if (segmentationInput.boardSize = [ boardW, options.size[1] ], segmentationInput.random ? segmentationInput.randomGenerator = Math.random : segmentationInput.randomGenerator = (0,_util__WEBPACK_IMPORTED_MODULE_1__.fakeRandom)(), \n        this.segmentationInput = segmentationInput, (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(segmentationInput.shapeUrl)) {\n            segmentationInput.isEmptyPixel = (0,_visactor_vgrammar_util__WEBPACK_IMPORTED_MODULE_3__.generateIsEmptyPixel)();\n            const imagePromise = (0,_util__WEBPACK_IMPORTED_MODULE_1__.loadImage)(segmentationInput.shapeUrl);\n            imagePromise ? (this.isImageFinished = !1, this.isLayoutFinished = !1, imagePromise.then((shapeImage => {\n                this.isImageFinished = !0;\n                const maskCanvas = _visactor_vrender_core__WEBPACK_IMPORTED_MODULE_0__.vglobal.createCanvas({\n                    width: options.size[0],\n                    height: options.size[1],\n                    dpr: 1\n                });\n                segmentationInput.maskCanvas = maskCanvas;\n                const ctx = maskCanvas.getContext(\"2d\");\n                options.removeWhiteBorder && (0,_segmentation__WEBPACK_IMPORTED_MODULE_4__.removeBorder)(shapeImage, maskCanvas, segmentationInput.isEmptyPixel);\n                const shapeConfig = (0,_segmentation__WEBPACK_IMPORTED_MODULE_4__.scaleAndMiddleShape)(shapeImage, options.size);\n                ctx.clearRect(0, 0, options.size[0], options.size[1]), ctx.drawImage(shapeImage, shapeConfig.x, shapeConfig.y, shapeConfig.width, shapeConfig.height), \n                this.options.onUpdateMaskCanvas && this.options.onUpdateMaskCanvas(segmentationInput.maskCanvas);\n            })).catch((error => {\n                this.isImageFinished = !0;\n            }))) : (this.isImageFinished = !0, this.isLayoutFinished = !0);\n        } else if (segmentationInput.shapeUrl && (\"text\" === segmentationInput.shapeUrl.type || \"geometric\" === segmentationInput.shapeUrl.type)) {\n            segmentationInput.isEmptyPixel = (0,_visactor_vgrammar_util__WEBPACK_IMPORTED_MODULE_3__.generateIsEmptyPixel)(segmentationInput.shapeUrl.backgroundColor);\n            const maskCanvas = (0,_visactor_vgrammar_util__WEBPACK_IMPORTED_MODULE_3__.generateMaskCanvas)(segmentationInput.shapeUrl, options.size[0], options.size[1]);\n            segmentationInput.maskCanvas = maskCanvas, this.options.onUpdateMaskCanvas && this.options.onUpdateMaskCanvas(maskCanvas), \n            this.doLayout(), this.isImageFinished = !0, this.isLayoutFinished = !0;\n        }\n    }\n    canAnimate() {\n        return !0;\n    }\n    unfinished() {\n        return !this.isLayoutFinished;\n    }\n    output() {\n        return this.progressiveResult;\n    }\n    progressiveRun() {\n        this.isImageFinished && !this.isLayoutFinished && (this.segmentationInput.maskCanvas && this.doLayout(), \n        this.isLayoutFinished = !0);\n    }\n    progressiveOutput() {\n        return this.progressiveResult;\n    }\n    doLayout() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;\n        const segmentationInput = this.segmentationInput, segmentationOutput = (0,_segmentation__WEBPACK_IMPORTED_MODULE_4__.segmentation)(segmentationInput);\n        if (!segmentationOutput.segmentation.regions.length) return;\n        const options = this.options, data = this.data, colorMode = options.colorMode || \"ordinal\", wordsConfig = {\n            getText: field(options.text),\n            getFontSize: field(options.fontSize),\n            fontSizeRange: options.fontSizeRange,\n            colorMode: colorMode,\n            getColor: options.colorField ? field(options.colorField) : field(options.text),\n            getFillingColor: field(options.fillingColorField),\n            colorList: options.colorList || (\"ordinal\" === colorMode ? [ \"#2E62F1\" ] : [ \"#537EF5\", \"#2E62F1\", \"#2358D8\", \"#184FBF\", \"#0C45A6\", \"#013B8E\" ]),\n            getColorHex: field(options.colorHexField),\n            getFontFamily: field(options.fontFamily || \"sans-serif\"),\n            rotateList: options.rotateList || [ 0 ],\n            getPadding: field(options.padding || 1),\n            getFontStyle: field(options.fontStyle || \"normal\"),\n            getFontWeight: field(options.fontWeight || \"normal\"),\n            getFontOpacity: options.fontOpacity ? field(options.fontOpacity) : () => 1\n        };\n        initFontSizeScale(data, wordsConfig, segmentationOutput);\n        const layoutConfig = {\n            size: options.size,\n            ratio: options.ratio || .8,\n            shapeUrl: options.shape,\n            random: void 0 === options.random || options.random,\n            textLayoutTimes: null !== (_a = options.textLayoutTimes) && void 0 !== _a ? _a : 3,\n            removeWhiteBorder: options.removeWhiteBorder,\n            layoutMode: null !== (_b = options.layoutMode) && void 0 !== _b ? _b : \"default\",\n            fontSizeShrinkFactor: null !== (_c = options.fontSizeShrinkFactor) && void 0 !== _c ? _c : .8,\n            stepFactor: null !== (_d = options.stepFactor) && void 0 !== _d ? _d : 1,\n            importantWordCount: null !== (_e = options.importantWordCount) && void 0 !== _e ? _e : 10,\n            globalShinkLimit: options.globalShinkLimit || .2,\n            fontSizeEnlargeFactor: null !== (_f = options.fontSizeEnlargeFactor) && void 0 !== _f ? _f : 1.5,\n            fillingRatio: null !== (_g = options.fillingRatio) && void 0 !== _g ? _g : .7,\n            fillingTimes: null !== (_h = options.fillingTimes) && void 0 !== _h ? _h : 4,\n            fillingXStep: options.fillingXRatioStep ? Math.max(Math.floor(options.size[0] * options.fillingXRatioStep), 1) : null !== (_j = options.fillingXStep) && void 0 !== _j ? _j : 4,\n            fillingYStep: options.fillingYRatioStep ? Math.max(Math.floor(options.size[1] * options.fillingYRatioStep), 1) : null !== (_k = options.fillingYStep) && void 0 !== _k ? _k : 4,\n            fillingInitialFontSize: options.fillingInitialFontSize,\n            fillingDeltaFontSize: options.fillingDeltaFontSize,\n            fillingInitialOpacity: null !== (_l = options.fillingInitialOpacity) && void 0 !== _l ? _l : .8,\n            fillingDeltaOpacity: null !== (_m = options.fillingDeltaOpacity) && void 0 !== _m ? _m : .05,\n            getFillingFontFamily: field(options.fillingFontFamily || \"sans-serif\"),\n            getFillingFontStyle: field(options.fillingFontStyle || \"normal\"),\n            getFillingFontWeight: field(options.fillingFontWeight || \"normal\"),\n            getFillingPadding: field(null !== (_o = options.fillingPadding) && void 0 !== _o ? _o : .4),\n            fillingRotateList: null !== (_p = options.fillingRotateList) && void 0 !== _p ? _p : [ 0, 90 ],\n            fillingDeltaFontSizeFactor: null !== (_q = options.fillingDeltaFontSizeFactor) && void 0 !== _q ? _q : .2,\n            fillingColorList: options.fillingColorList || [ \"#537EF5\" ],\n            sameColorList: !1,\n            minInitFontSize: null !== (_r = options.minInitFontSize) && void 0 !== _r ? _r : 10,\n            minFontSize: null !== (_s = options.minFontSize) && void 0 !== _s ? _s : 4,\n            minFillFontSize: null !== (_t = options.minFillFontSize) && void 0 !== _t ? _t : 2\n        }, sameColorList = (0,_util__WEBPACK_IMPORTED_MODULE_1__.colorListEqual)(wordsConfig.colorList, layoutConfig.fillingColorList);\n        layoutConfig.sameColorList = sameColorList, initColorScale(data, wordsConfig, layoutConfig, options), \n        initFillingWordsFontSize(data, wordsConfig, layoutConfig, segmentationOutput);\n        const {getText: getText, getFontFamily: getFontFamily, getFontStyle: getFontStyle, getFontWeight: getFontWeight, getPadding: getPadding, getColor: getColor, getFillingColor: getFillingColor, getColorHex: getColorHex, fontSizeScale: fontSizeScale, colorScale: colorScale, fillingColorScale: fillingColorScale, getFontOpacity: getFontOpacity, rotateList: rotateList} = wordsConfig, words = data.map((datum => {\n            var _a, _b;\n            return {\n                x: 0,\n                y: 0,\n                weight: 0,\n                text: getText(datum),\n                fontFamily: getFontFamily(datum),\n                fontWeight: getFontWeight(datum),\n                fontStyle: getFontStyle(datum),\n                rotate: rotateList[~~(segmentationInput.randomGenerator() * rotateList.length)],\n                fontSize: Math.max(layoutConfig.minInitFontSize, ~~fontSizeScale(datum)),\n                opacity: getFontOpacity(datum),\n                padding: getPadding(datum),\n                color: getColorHex && getColorHex(datum) || colorScale && colorScale(getColor(datum)) || \"black\",\n                fillingColor: !getFillingColor || (null === (_a = options.colorField) || void 0 === _a ? void 0 : _a.field) === (null === (_b = options.fillingColorField) || void 0 === _b ? void 0 : _b.field) && sameColorList ? void 0 : getColorHex && getColorHex(datum) || fillingColorScale && fillingColorScale(getFillingColor(datum)) || \"black\",\n                datum: datum,\n                visible: !0,\n                hasPlaced: !1\n            };\n        })), wordsMaxFontSize = (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_5__.maxInArray)(words.map((word => word.fontSize)));\n        words.forEach((word => word.weight = word.fontSize / wordsMaxFontSize)), words.sort(((a, b) => b.weight - a.weight));\n        const {fillingWords: fillingWords, successedWords: successedWords, failedWords: failedWords} = (0,_cloud_shape_layout__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(words, layoutConfig, segmentationOutput), textKey = null !== (_v = null === (_u = options.text) || void 0 === _u ? void 0 : _u.field) && void 0 !== _v ? _v : \"textKey\", dataIndexKey = null !== (_w = options.dataIndexKey) && void 0 !== _w ? _w : \"defaultDataIndexKey\", as = options.as ? Object.assign(Object.assign({}, OUTPUT), options.as) : OUTPUT;\n        let w, t;\n        const modKeywords = [];\n        for (let i = 0; i < words.length; ++i) w = words[i], t = w.datum, t[as.x] = w.x, \n        t[as.y] = w.y, t[as.fontFamily] = w.fontFamily, t[as.fontSize] = w.fontSize, t[as.fontStyle] = w.fontStyle, \n        t[as.fontWeight] = w.fontWeight, t[as.angle] = (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_7__.degreeToRadian)(w.rotate), t[as.opacity] = w.opacity, \n        t[as.visible] = w.visible, t[as.isFillingWord] = !1, t[as.color] = w.color, t[dataIndexKey] = `${w.text}_${i}_keyword`, \n        modKeywords.push(t);\n        const fillingWordsData = [];\n        if (fillingWords.forEach(((word, index) => {\n            var _a, _b;\n            const t = Object.assign({}, word.datum);\n            t[as.x] = word.x, t[as.y] = word.y, t[as.fontFamily] = word.fontFamily, t[as.fontSize] = word.fontSize, \n            t[as.fontStyle] = word.fontStyle, t[as.fontWeight] = word.fontWeight, t[as.angle] = (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_7__.degreeToRadian)(word.rotate), \n            t[as.opacity] = word.opacity, t[as.visible] = word.visible, t[as.isFillingWord] = !0, \n            t[as.color] = getFillingColor ? (null === (_a = options.colorField) || void 0 === _a ? void 0 : _a.field) === (null === (_b = options.fillingColorField) || void 0 === _b ? void 0 : _b.field) && sameColorList ? word.color : word.fillingColor : layoutConfig.fillingColorList[~~(segmentationInput.randomGenerator() * layoutConfig.fillingColorList.length)], \n            t[textKey] = word.text, t[dataIndexKey] = `${word.text}_${index}_fillingWords`, \n            fillingWordsData.push(t);\n        })), this.view && this.view.emit) {\n            this.view.emit(_util__WEBPACK_IMPORTED_MODULE_1__.WORDCLOUD_SHAPE_HOOK_EVENT.AFTER_WORDCLOUD_SHAPE_LAYOUT, {\n                successedWords: successedWords,\n                failedWords: failedWords\n            });\n            const stage = null === (_x = this.view.renderer) || void 0 === _x ? void 0 : _x.stage();\n            stage && stage.hooks.afterRender.tap(_util__WEBPACK_IMPORTED_MODULE_1__.WORDCLOUD_SHAPE_HOOK_EVENT.AFTER_WORDCLOUD_SHAPE_DRAW, (() => {\n                this.view.emit(_util__WEBPACK_IMPORTED_MODULE_1__.WORDCLOUD_SHAPE_HOOK_EVENT.AFTER_WORDCLOUD_SHAPE_DRAW, {\n                    successedWords: successedWords,\n                    failedWords: failedWords\n                }), stage.hooks.afterRender.unTap(_util__WEBPACK_IMPORTED_MODULE_1__.WORDCLOUD_SHAPE_HOOK_EVENT.AFTER_WORDCLOUD_SHAPE_DRAW);\n            }));\n        }\n        this.progressiveResult = modKeywords.concat(fillingWordsData);\n    }\n    release() {\n        this.segmentationInput = null, this.data = null, this.progressiveResult = null, \n        this.options = null;\n    }\n}\n\nconst initColorScale = (data, wordsConfig, layoutConfig, options) => {\n    var _a, _b, _c, _d;\n    const {colorMode: colorMode, getColor: getColor, getFillingColor: getFillingColor} = wordsConfig, {sameColorList: sameColorList} = layoutConfig;\n    let colorScale, fillingColorScale, colorList = wordsConfig.colorList, fillingColorList = layoutConfig.fillingColorList;\n    if (\"ordinal\" === colorMode) {\n        const uniqueColorField = data.map((word => getColor(word)));\n        if (colorScale = datum => (new _visactor_vscale__WEBPACK_IMPORTED_MODULE_8__.OrdinalScale).domain(uniqueColorField).range(colorList).scale(datum), \n        getFillingColor && ((null === (_a = options.colorField) || void 0 === _a ? void 0 : _a.field) !== (null === (_b = options.fillingColorField) || void 0 === _b ? void 0 : _b.field) || !sameColorList)) {\n            const uniquefillingColorField = data.map((datum => getFillingColor(datum)));\n            fillingColorScale = datum => (new _visactor_vscale__WEBPACK_IMPORTED_MODULE_8__.OrdinalScale).domain(uniquefillingColorField).range(fillingColorList).scale(datum);\n        }\n    } else {\n        1 === colorList.length && (colorList = [ colorList[0], colorList[0] ]);\n        const valueScale = (new _visactor_vscale__WEBPACK_IMPORTED_MODULE_9__.LinearScale).domain(extent(getColor, data)).range(colorList);\n        if (colorScale = i => valueScale.scale(i), getFillingColor && ((null === (_c = options.colorField) || void 0 === _c ? void 0 : _c.field) !== (null === (_d = options.fillingColorField) || void 0 === _d ? void 0 : _d.field) || !sameColorList)) {\n            1 === fillingColorList.length && (fillingColorList = [ fillingColorList[0], fillingColorList[0] ]);\n            const fillingValueScale = (new _visactor_vscale__WEBPACK_IMPORTED_MODULE_9__.LinearScale).domain(extent(getFillingColor, data)).range(fillingColorList);\n            fillingColorScale = i => fillingValueScale.scale(i);\n        }\n    }\n    Object.assign(wordsConfig, {\n        colorScale: colorScale,\n        fillingColorScale: fillingColorScale\n    });\n}, initFontSizeScale = (data, wordsConfig, segmentationOutput) => {\n    let {fontSizeRange: range} = wordsConfig;\n    const {getFontSize: getFontSize, getText: getText} = wordsConfig;\n    let fontSizeScale;\n    if (getFontSize) {\n        if (getFontSize && range) {\n            const sizeScale = (new _visactor_vscale__WEBPACK_IMPORTED_MODULE_10__.SqrtScale).domain(extent(getFontSize, data)).range(range);\n            fontSizeScale = datum => sizeScale.scale(getFontSize(datum));\n        } else if (getFontSize && (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(getFontSize) && !range) {\n            const a = .5, [min, max] = extent(getFontSize, data), words = data.map((datum => ({\n                text: getText(datum),\n                value: getFontSize(datum),\n                weight: max === min ? 1 : (getFontSize(datum) - min) / (max - min)\n            }))), x = getInitialFontSize(words, segmentationOutput, !0);\n            range = [ ~~(a * x), ~~x ];\n            const sizeScale = (new _visactor_vscale__WEBPACK_IMPORTED_MODULE_10__.SqrtScale).domain(extent(getFontSize, data)).range(range);\n            fontSizeScale = datum => sizeScale.scale(getFontSize(datum));\n        }\n    } else {\n        const words = data.map((word => ({\n            text: getText(word)\n        }))), x = getInitialFontSize(words, segmentationOutput, !1);\n        fontSizeScale = (0,_util__WEBPACK_IMPORTED_MODULE_1__.functor)(x);\n    }\n    Object.assign(wordsConfig, {\n        getFontSize: getFontSize,\n        fontSizeRange: range,\n        fontSizeScale: fontSizeScale\n    });\n}, getInitialFontSize = (words, segmentationOutput, weight) => {\n    const shapeArea = segmentationOutput.shapeArea, ratio = segmentationOutput.ratio, regions = segmentationOutput.segmentation.regions, shapeSizeLimitTextLength = Math.ceil(Math.sqrt(shapeArea) / 12), wordArea = words.reduce(((acc, word) => {\n        const textLength = (0,_util__WEBPACK_IMPORTED_MODULE_1__.calTextLength)(word.text);\n        return textLength < shapeSizeLimitTextLength ? acc + textLength * (weight ? (.5 + .5 * word.weight) ** 2 : 1) : acc;\n    }), 0);\n    if (0 === wordArea) return 12;\n    let x = 20;\n    if (1 === regions.length) x = Math.sqrt(ratio * (shapeArea / (1.7 * wordArea))); else {\n        const xArr = [];\n        for (let i = 0; i < regions.length; i++) {\n            const regionArea = regions[i].area, regionAspect = regions[i].ratio, regionRatio = regionArea / shapeArea;\n            if (regionRatio < .1) continue;\n            const regionWordArea = regionRatio * (wordArea * (regionAspect < 1 ? 2.7 - regionAspect : 1.7)), x = Math.sqrt(ratio * (regionArea / regionWordArea));\n            xArr.push(x);\n        }\n        x = xArr.length ? Math.min(...xArr) : Math.sqrt(ratio * (shapeArea / (1.7 * wordArea)));\n    }\n    return x;\n};\n\nfunction initFillingWordsFontSize(data, wordsConfig, layoutConfig, segmentationOutput) {\n    const {getText: getText} = wordsConfig;\n    let {fillingInitialFontSize: fillingInitialFontSize, fillingDeltaFontSize: fillingDeltaFontSize} = layoutConfig;\n    const {fillingRatio: fillingRatio} = layoutConfig, shapeSizeLimitTextLength = Math.ceil(Math.sqrt(segmentationOutput.shapeArea) / 4);\n    if (!fillingInitialFontSize || !fillingDeltaFontSize) {\n        const a = fillingRatio / 100, averageLength = data.reduce(((acc, word) => {\n            const length = (0,_util__WEBPACK_IMPORTED_MODULE_1__.calTextLength)(getText(word));\n            return length > shapeSizeLimitTextLength ? acc : acc + length;\n        }), 0) / data.length;\n        let fontSize;\n        if (0 === averageLength) fontSize = 8; else {\n            const area = .2 * segmentationOutput.shapeArea;\n            fontSize = Math.sqrt(a * (area / averageLength));\n        }\n        fillingInitialFontSize = ~~fontSize, fillingDeltaFontSize = fontSize * layoutConfig.fillingDeltaFontSizeFactor, \n        Object.assign(layoutConfig, {\n            fillingInitialFontSize: fillingInitialFontSize,\n            fillingDeltaFontSize: fillingDeltaFontSize\n        });\n    }\n}\n\nconst extent = (field, data) => {\n    let min = 1 / 0, max = -1 / 0;\n    const n = data.length;\n    let v;\n    for (let i = 0; i < n; ++i) v = (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_12__.toNumber)(field(data[i])), v < min && (min = v), \n    v > max && (max = v);\n    return 1 === data.length && min === max && (min -= 1e4), [ min, max ];\n}, field = option => option ? \"string\" == typeof option || \"number\" == typeof option ? () => option : (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(option) ? option : datum => datum[option.field] : null;\n//# sourceMappingURL=layout.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZUAwLjE0LjEzL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItd29yZGNsb3VkLXNoYXBlL2VzL2xheW91dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUE4Rjs7QUFFYjs7QUFFa0M7O0FBRTNDOztBQUUvQjs7QUFFUTs7QUFFa0M7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGVBQWUsMkRBQU87QUFDL0I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0xBQXdMLGlEQUFVO0FBQ2xNLG9EQUFvRCw0REFBUTtBQUM1RCw2Q0FBNkMsNkVBQW9CO0FBQ2pFLGlDQUFpQyxnREFBUztBQUMxQztBQUNBO0FBQ0EsbUNBQW1DLDJEQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsNkNBQTZDLDJEQUFZO0FBQ3pELG9DQUFvQyxrRUFBbUI7QUFDdkQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1YsNkNBQTZDLDZFQUFvQjtBQUNqRSwrQkFBK0IsMkVBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLDJEQUFZO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGtCQUFrQixxREFBYztBQUN6QztBQUNBO0FBQ0EsZUFBZSxzV0FBc1c7QUFDclg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHVCQUF1Qiw0REFBVTtBQUMxQztBQUNBLGVBQWUsc0ZBQXNGLEVBQUUsK0RBQUssNlRBQTZUO0FBQ3phO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0EsdURBQXVELGdFQUFjO0FBQ3JFLHlHQUF5RyxPQUFPLEdBQUcsRUFBRTtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLGdHQUFnRyxnRUFBYztBQUM5RztBQUNBO0FBQ0EseURBQXlELFVBQVUsR0FBRyxNQUFNO0FBQzVFO0FBQ0EsU0FBUztBQUNULDJCQUEyQiw2REFBMEI7QUFDckQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGlEQUFpRCw2REFBMEI7QUFDM0UsK0JBQStCLDZEQUEwQjtBQUN6RDtBQUNBO0FBQ0EsaUJBQWlCLGlDQUFpQyw2REFBMEI7QUFDNUUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsNEVBQTRFLGdCQUFnQiw4QkFBOEI7QUFDckk7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDBEQUFZO0FBQ25EO0FBQ0E7QUFDQSw4Q0FBOEMsMERBQVk7QUFDMUQ7QUFDQSxNQUFNO0FBQ047QUFDQSxnQ0FBZ0MseURBQVc7QUFDM0M7QUFDQTtBQUNBLDJDQUEyQyx5REFBVztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELFNBQVMsc0JBQXNCO0FBQy9CLFdBQVcsNENBQTRDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx3REFBUztBQUM1QztBQUNBLFVBQVUsd0JBQXdCLDZEQUFVO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsbUNBQW1DLHdEQUFTO0FBQzVDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFNBQVM7QUFDVCx3QkFBd0IsOENBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQSwyQkFBMkIsb0RBQWE7QUFDeEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsU0FBUyw0RkFBNEY7QUFDckcsV0FBVyw0QkFBNEI7QUFDdkM7QUFDQTtBQUNBLDJCQUEyQixvREFBYTtBQUN4QztBQUNBLFNBQVM7QUFDVDtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU8sU0FBUywyREFBUTtBQUM1QztBQUNBO0FBQ0EsQ0FBQyxxR0FBcUcsNkRBQVU7QUFDaEgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9meW5sYXRpY3MtYWkvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZUAwLjE0LjEzL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItd29yZGNsb3VkLXNoYXBlL2VzL2xheW91dC5qcz85ZTBmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlZ3JlZVRvUmFkaWFuLCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgbWF4SW5BcnJheSwgdG9OdW1iZXIgfSBmcm9tIFwiQHZpc2FjdG9yL3Z1dGlsc1wiO1xuXG5pbXBvcnQgeyByZW1vdmVCb3JkZXIsIHNjYWxlQW5kTWlkZGxlU2hhcGUsIHNlZ21lbnRhdGlvbiB9IGZyb20gXCIuL3NlZ21lbnRhdGlvblwiO1xuXG5pbXBvcnQgeyBXT1JEQ0xPVURfU0hBUEVfSE9PS19FVkVOVCwgY2FsVGV4dExlbmd0aCwgY29sb3JMaXN0RXF1YWwsIGZha2VSYW5kb20sIGZ1bmN0b3IsIGxvYWRJbWFnZSB9IGZyb20gXCIuL3V0aWxcIjtcblxuaW1wb3J0IHsgTGluZWFyU2NhbGUsIE9yZGluYWxTY2FsZSwgU3FydFNjYWxlIH0gZnJvbSBcIkB2aXNhY3Rvci92c2NhbGVcIjtcblxuaW1wb3J0IGNsb3VkIGZyb20gXCIuL2Nsb3VkLXNoYXBlLWxheW91dFwiO1xuXG5pbXBvcnQgeyB2Z2xvYmFsIH0gZnJvbSBcIkB2aXNhY3Rvci92cmVuZGVyLWNvcmVcIjtcblxuaW1wb3J0IHsgZ2VuZXJhdGVJc0VtcHR5UGl4ZWwsIGdlbmVyYXRlTWFza0NhbnZhcyB9IGZyb20gXCJAdmlzYWN0b3IvdmdyYW1tYXItdXRpbFwiO1xuXG5jb25zdCBPVVRQVVQgPSB7XG4gICAgeDogXCJ4XCIsXG4gICAgeTogXCJ5XCIsXG4gICAgZm9udEZhbWlseTogXCJmb250RmFtaWx5XCIsXG4gICAgZm9udFNpemU6IFwiZm9udFNpemVcIixcbiAgICBmb250U3R5bGU6IFwiZm9udFN0eWxlXCIsXG4gICAgZm9udFdlaWdodDogXCJmb250V2VpZ2h0XCIsXG4gICAgYW5nbGU6IFwiYW5nbGVcIixcbiAgICBvcGFjaXR5OiBcIm9wYWNpdHlcIixcbiAgICB2aXNpYmxlOiBcInZpc2libGVcIixcbiAgICBpc0ZpbGxpbmdXb3JkOiBcImlzRmlsbGluZ1dvcmRcIixcbiAgICBjb2xvcjogXCJjb2xvclwiXG59O1xuXG5leHBvcnQgY2xhc3MgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCB2aWV3KSB7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3NpdmVSZXN1bHQgPSBbXSwgdGhpcy5vcHRpb25zID0gb3B0aW9ucywgdGhpcy52aWV3ID0gdmlldztcbiAgICB9XG4gICAgbGF5b3V0KGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucywgc2VnbWVudGF0aW9uSW5wdXQgPSB7XG4gICAgICAgICAgICBzaGFwZVVybDogb3B0aW9ucy5zaGFwZSxcbiAgICAgICAgICAgIHNpemU6IG9wdGlvbnMuc2l6ZSxcbiAgICAgICAgICAgIHJhdGlvOiBvcHRpb25zLnJhdGlvIHx8IC44LFxuICAgICAgICAgICAgdGVtcENhbnZhczogdm9pZCAwLFxuICAgICAgICAgICAgYm9hcmRTaXplOiBbIDAsIDAgXSxcbiAgICAgICAgICAgIHJhbmRvbTogITEsXG4gICAgICAgICAgICByYW5kb21HZW5lcmF0b3I6IHZvaWQgMFxuICAgICAgICB9LCB0ZW1wQ2FudmFzID0gdmdsb2JhbC5jcmVhdGVDYW52YXMoe1xuICAgICAgICAgICAgd2lkdGg6IG9wdGlvbnMuc2l6ZVswXSxcbiAgICAgICAgICAgIGhlaWdodDogb3B0aW9ucy5zaXplWzFdXG4gICAgICAgIH0pLCB0ZW1wQ3R4ID0gdGVtcENhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiAhMFxuICAgICAgICB9KTtcbiAgICAgICAgdGVtcEN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiLCB0ZW1wQ3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCIsIHNlZ21lbnRhdGlvbklucHV0LnRlbXBDYW52YXMgPSB0ZW1wQ2FudmFzO1xuICAgICAgICBjb25zdCBib2FyZFcgPSBvcHRpb25zLnNpemVbMF0gKyAzMSA+PiA1IDw8IDU7XG4gICAgICAgIGlmIChzZWdtZW50YXRpb25JbnB1dC5ib2FyZFNpemUgPSBbIGJvYXJkVywgb3B0aW9ucy5zaXplWzFdIF0sIHNlZ21lbnRhdGlvbklucHV0LnJhbmRvbSA/IHNlZ21lbnRhdGlvbklucHV0LnJhbmRvbUdlbmVyYXRvciA9IE1hdGgucmFuZG9tIDogc2VnbWVudGF0aW9uSW5wdXQucmFuZG9tR2VuZXJhdG9yID0gZmFrZVJhbmRvbSgpLCBcbiAgICAgICAgdGhpcy5zZWdtZW50YXRpb25JbnB1dCA9IHNlZ21lbnRhdGlvbklucHV0LCBpc1N0cmluZyhzZWdtZW50YXRpb25JbnB1dC5zaGFwZVVybCkpIHtcbiAgICAgICAgICAgIHNlZ21lbnRhdGlvbklucHV0LmlzRW1wdHlQaXhlbCA9IGdlbmVyYXRlSXNFbXB0eVBpeGVsKCk7XG4gICAgICAgICAgICBjb25zdCBpbWFnZVByb21pc2UgPSBsb2FkSW1hZ2Uoc2VnbWVudGF0aW9uSW5wdXQuc2hhcGVVcmwpO1xuICAgICAgICAgICAgaW1hZ2VQcm9taXNlID8gKHRoaXMuaXNJbWFnZUZpbmlzaGVkID0gITEsIHRoaXMuaXNMYXlvdXRGaW5pc2hlZCA9ICExLCBpbWFnZVByb21pc2UudGhlbigoc2hhcGVJbWFnZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0ltYWdlRmluaXNoZWQgPSAhMDtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXNrQ2FudmFzID0gdmdsb2JhbC5jcmVhdGVDYW52YXMoe1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogb3B0aW9ucy5zaXplWzBdLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG9wdGlvbnMuc2l6ZVsxXSxcbiAgICAgICAgICAgICAgICAgICAgZHByOiAxXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2VnbWVudGF0aW9uSW5wdXQubWFza0NhbnZhcyA9IG1hc2tDYW52YXM7XG4gICAgICAgICAgICAgICAgY29uc3QgY3R4ID0gbWFza0NhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5yZW1vdmVXaGl0ZUJvcmRlciAmJiByZW1vdmVCb3JkZXIoc2hhcGVJbWFnZSwgbWFza0NhbnZhcywgc2VnbWVudGF0aW9uSW5wdXQuaXNFbXB0eVBpeGVsKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaGFwZUNvbmZpZyA9IHNjYWxlQW5kTWlkZGxlU2hhcGUoc2hhcGVJbWFnZSwgb3B0aW9ucy5zaXplKTtcbiAgICAgICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIG9wdGlvbnMuc2l6ZVswXSwgb3B0aW9ucy5zaXplWzFdKSwgY3R4LmRyYXdJbWFnZShzaGFwZUltYWdlLCBzaGFwZUNvbmZpZy54LCBzaGFwZUNvbmZpZy55LCBzaGFwZUNvbmZpZy53aWR0aCwgc2hhcGVDb25maWcuaGVpZ2h0KSwgXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uVXBkYXRlTWFza0NhbnZhcyAmJiB0aGlzLm9wdGlvbnMub25VcGRhdGVNYXNrQ2FudmFzKHNlZ21lbnRhdGlvbklucHV0Lm1hc2tDYW52YXMpO1xuICAgICAgICAgICAgfSkpLmNhdGNoKChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0ltYWdlRmluaXNoZWQgPSAhMDtcbiAgICAgICAgICAgIH0pKSkgOiAodGhpcy5pc0ltYWdlRmluaXNoZWQgPSAhMCwgdGhpcy5pc0xheW91dEZpbmlzaGVkID0gITApO1xuICAgICAgICB9IGVsc2UgaWYgKHNlZ21lbnRhdGlvbklucHV0LnNoYXBlVXJsICYmIChcInRleHRcIiA9PT0gc2VnbWVudGF0aW9uSW5wdXQuc2hhcGVVcmwudHlwZSB8fCBcImdlb21ldHJpY1wiID09PSBzZWdtZW50YXRpb25JbnB1dC5zaGFwZVVybC50eXBlKSkge1xuICAgICAgICAgICAgc2VnbWVudGF0aW9uSW5wdXQuaXNFbXB0eVBpeGVsID0gZ2VuZXJhdGVJc0VtcHR5UGl4ZWwoc2VnbWVudGF0aW9uSW5wdXQuc2hhcGVVcmwuYmFja2dyb3VuZENvbG9yKTtcbiAgICAgICAgICAgIGNvbnN0IG1hc2tDYW52YXMgPSBnZW5lcmF0ZU1hc2tDYW52YXMoc2VnbWVudGF0aW9uSW5wdXQuc2hhcGVVcmwsIG9wdGlvbnMuc2l6ZVswXSwgb3B0aW9ucy5zaXplWzFdKTtcbiAgICAgICAgICAgIHNlZ21lbnRhdGlvbklucHV0Lm1hc2tDYW52YXMgPSBtYXNrQ2FudmFzLCB0aGlzLm9wdGlvbnMub25VcGRhdGVNYXNrQ2FudmFzICYmIHRoaXMub3B0aW9ucy5vblVwZGF0ZU1hc2tDYW52YXMobWFza0NhbnZhcyksIFxuICAgICAgICAgICAgdGhpcy5kb0xheW91dCgpLCB0aGlzLmlzSW1hZ2VGaW5pc2hlZCA9ICEwLCB0aGlzLmlzTGF5b3V0RmluaXNoZWQgPSAhMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5BbmltYXRlKCkge1xuICAgICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIHVuZmluaXNoZWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc0xheW91dEZpbmlzaGVkO1xuICAgIH1cbiAgICBvdXRwdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2dyZXNzaXZlUmVzdWx0O1xuICAgIH1cbiAgICBwcm9ncmVzc2l2ZVJ1bigpIHtcbiAgICAgICAgdGhpcy5pc0ltYWdlRmluaXNoZWQgJiYgIXRoaXMuaXNMYXlvdXRGaW5pc2hlZCAmJiAodGhpcy5zZWdtZW50YXRpb25JbnB1dC5tYXNrQ2FudmFzICYmIHRoaXMuZG9MYXlvdXQoKSwgXG4gICAgICAgIHRoaXMuaXNMYXlvdXRGaW5pc2hlZCA9ICEwKTtcbiAgICB9XG4gICAgcHJvZ3Jlc3NpdmVPdXRwdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2dyZXNzaXZlUmVzdWx0O1xuICAgIH1cbiAgICBkb0xheW91dCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX20sIF9vLCBfcCwgX3EsIF9yLCBfcywgX3QsIF91LCBfdiwgX3csIF94O1xuICAgICAgICBjb25zdCBzZWdtZW50YXRpb25JbnB1dCA9IHRoaXMuc2VnbWVudGF0aW9uSW5wdXQsIHNlZ21lbnRhdGlvbk91dHB1dCA9IHNlZ21lbnRhdGlvbihzZWdtZW50YXRpb25JbnB1dCk7XG4gICAgICAgIGlmICghc2VnbWVudGF0aW9uT3V0cHV0LnNlZ21lbnRhdGlvbi5yZWdpb25zLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLCBkYXRhID0gdGhpcy5kYXRhLCBjb2xvck1vZGUgPSBvcHRpb25zLmNvbG9yTW9kZSB8fCBcIm9yZGluYWxcIiwgd29yZHNDb25maWcgPSB7XG4gICAgICAgICAgICBnZXRUZXh0OiBmaWVsZChvcHRpb25zLnRleHQpLFxuICAgICAgICAgICAgZ2V0Rm9udFNpemU6IGZpZWxkKG9wdGlvbnMuZm9udFNpemUpLFxuICAgICAgICAgICAgZm9udFNpemVSYW5nZTogb3B0aW9ucy5mb250U2l6ZVJhbmdlLFxuICAgICAgICAgICAgY29sb3JNb2RlOiBjb2xvck1vZGUsXG4gICAgICAgICAgICBnZXRDb2xvcjogb3B0aW9ucy5jb2xvckZpZWxkID8gZmllbGQob3B0aW9ucy5jb2xvckZpZWxkKSA6IGZpZWxkKG9wdGlvbnMudGV4dCksXG4gICAgICAgICAgICBnZXRGaWxsaW5nQ29sb3I6IGZpZWxkKG9wdGlvbnMuZmlsbGluZ0NvbG9yRmllbGQpLFxuICAgICAgICAgICAgY29sb3JMaXN0OiBvcHRpb25zLmNvbG9yTGlzdCB8fCAoXCJvcmRpbmFsXCIgPT09IGNvbG9yTW9kZSA/IFsgXCIjMkU2MkYxXCIgXSA6IFsgXCIjNTM3RUY1XCIsIFwiIzJFNjJGMVwiLCBcIiMyMzU4RDhcIiwgXCIjMTg0RkJGXCIsIFwiIzBDNDVBNlwiLCBcIiMwMTNCOEVcIiBdKSxcbiAgICAgICAgICAgIGdldENvbG9ySGV4OiBmaWVsZChvcHRpb25zLmNvbG9ySGV4RmllbGQpLFxuICAgICAgICAgICAgZ2V0Rm9udEZhbWlseTogZmllbGQob3B0aW9ucy5mb250RmFtaWx5IHx8IFwic2Fucy1zZXJpZlwiKSxcbiAgICAgICAgICAgIHJvdGF0ZUxpc3Q6IG9wdGlvbnMucm90YXRlTGlzdCB8fCBbIDAgXSxcbiAgICAgICAgICAgIGdldFBhZGRpbmc6IGZpZWxkKG9wdGlvbnMucGFkZGluZyB8fCAxKSxcbiAgICAgICAgICAgIGdldEZvbnRTdHlsZTogZmllbGQob3B0aW9ucy5mb250U3R5bGUgfHwgXCJub3JtYWxcIiksXG4gICAgICAgICAgICBnZXRGb250V2VpZ2h0OiBmaWVsZChvcHRpb25zLmZvbnRXZWlnaHQgfHwgXCJub3JtYWxcIiksXG4gICAgICAgICAgICBnZXRGb250T3BhY2l0eTogb3B0aW9ucy5mb250T3BhY2l0eSA/IGZpZWxkKG9wdGlvbnMuZm9udE9wYWNpdHkpIDogKCkgPT4gMVxuICAgICAgICB9O1xuICAgICAgICBpbml0Rm9udFNpemVTY2FsZShkYXRhLCB3b3Jkc0NvbmZpZywgc2VnbWVudGF0aW9uT3V0cHV0KTtcbiAgICAgICAgY29uc3QgbGF5b3V0Q29uZmlnID0ge1xuICAgICAgICAgICAgc2l6ZTogb3B0aW9ucy5zaXplLFxuICAgICAgICAgICAgcmF0aW86IG9wdGlvbnMucmF0aW8gfHwgLjgsXG4gICAgICAgICAgICBzaGFwZVVybDogb3B0aW9ucy5zaGFwZSxcbiAgICAgICAgICAgIHJhbmRvbTogdm9pZCAwID09PSBvcHRpb25zLnJhbmRvbSB8fCBvcHRpb25zLnJhbmRvbSxcbiAgICAgICAgICAgIHRleHRMYXlvdXRUaW1lczogbnVsbCAhPT0gKF9hID0gb3B0aW9ucy50ZXh0TGF5b3V0VGltZXMpICYmIHZvaWQgMCAhPT0gX2EgPyBfYSA6IDMsXG4gICAgICAgICAgICByZW1vdmVXaGl0ZUJvcmRlcjogb3B0aW9ucy5yZW1vdmVXaGl0ZUJvcmRlcixcbiAgICAgICAgICAgIGxheW91dE1vZGU6IG51bGwgIT09IChfYiA9IG9wdGlvbnMubGF5b3V0TW9kZSkgJiYgdm9pZCAwICE9PSBfYiA/IF9iIDogXCJkZWZhdWx0XCIsXG4gICAgICAgICAgICBmb250U2l6ZVNocmlua0ZhY3RvcjogbnVsbCAhPT0gKF9jID0gb3B0aW9ucy5mb250U2l6ZVNocmlua0ZhY3RvcikgJiYgdm9pZCAwICE9PSBfYyA/IF9jIDogLjgsXG4gICAgICAgICAgICBzdGVwRmFjdG9yOiBudWxsICE9PSAoX2QgPSBvcHRpb25zLnN0ZXBGYWN0b3IpICYmIHZvaWQgMCAhPT0gX2QgPyBfZCA6IDEsXG4gICAgICAgICAgICBpbXBvcnRhbnRXb3JkQ291bnQ6IG51bGwgIT09IChfZSA9IG9wdGlvbnMuaW1wb3J0YW50V29yZENvdW50KSAmJiB2b2lkIDAgIT09IF9lID8gX2UgOiAxMCxcbiAgICAgICAgICAgIGdsb2JhbFNoaW5rTGltaXQ6IG9wdGlvbnMuZ2xvYmFsU2hpbmtMaW1pdCB8fCAuMixcbiAgICAgICAgICAgIGZvbnRTaXplRW5sYXJnZUZhY3RvcjogbnVsbCAhPT0gKF9mID0gb3B0aW9ucy5mb250U2l6ZUVubGFyZ2VGYWN0b3IpICYmIHZvaWQgMCAhPT0gX2YgPyBfZiA6IDEuNSxcbiAgICAgICAgICAgIGZpbGxpbmdSYXRpbzogbnVsbCAhPT0gKF9nID0gb3B0aW9ucy5maWxsaW5nUmF0aW8pICYmIHZvaWQgMCAhPT0gX2cgPyBfZyA6IC43LFxuICAgICAgICAgICAgZmlsbGluZ1RpbWVzOiBudWxsICE9PSAoX2ggPSBvcHRpb25zLmZpbGxpbmdUaW1lcykgJiYgdm9pZCAwICE9PSBfaCA/IF9oIDogNCxcbiAgICAgICAgICAgIGZpbGxpbmdYU3RlcDogb3B0aW9ucy5maWxsaW5nWFJhdGlvU3RlcCA/IE1hdGgubWF4KE1hdGguZmxvb3Iob3B0aW9ucy5zaXplWzBdICogb3B0aW9ucy5maWxsaW5nWFJhdGlvU3RlcCksIDEpIDogbnVsbCAhPT0gKF9qID0gb3B0aW9ucy5maWxsaW5nWFN0ZXApICYmIHZvaWQgMCAhPT0gX2ogPyBfaiA6IDQsXG4gICAgICAgICAgICBmaWxsaW5nWVN0ZXA6IG9wdGlvbnMuZmlsbGluZ1lSYXRpb1N0ZXAgPyBNYXRoLm1heChNYXRoLmZsb29yKG9wdGlvbnMuc2l6ZVsxXSAqIG9wdGlvbnMuZmlsbGluZ1lSYXRpb1N0ZXApLCAxKSA6IG51bGwgIT09IChfayA9IG9wdGlvbnMuZmlsbGluZ1lTdGVwKSAmJiB2b2lkIDAgIT09IF9rID8gX2sgOiA0LFxuICAgICAgICAgICAgZmlsbGluZ0luaXRpYWxGb250U2l6ZTogb3B0aW9ucy5maWxsaW5nSW5pdGlhbEZvbnRTaXplLFxuICAgICAgICAgICAgZmlsbGluZ0RlbHRhRm9udFNpemU6IG9wdGlvbnMuZmlsbGluZ0RlbHRhRm9udFNpemUsXG4gICAgICAgICAgICBmaWxsaW5nSW5pdGlhbE9wYWNpdHk6IG51bGwgIT09IChfbCA9IG9wdGlvbnMuZmlsbGluZ0luaXRpYWxPcGFjaXR5KSAmJiB2b2lkIDAgIT09IF9sID8gX2wgOiAuOCxcbiAgICAgICAgICAgIGZpbGxpbmdEZWx0YU9wYWNpdHk6IG51bGwgIT09IChfbSA9IG9wdGlvbnMuZmlsbGluZ0RlbHRhT3BhY2l0eSkgJiYgdm9pZCAwICE9PSBfbSA/IF9tIDogLjA1LFxuICAgICAgICAgICAgZ2V0RmlsbGluZ0ZvbnRGYW1pbHk6IGZpZWxkKG9wdGlvbnMuZmlsbGluZ0ZvbnRGYW1pbHkgfHwgXCJzYW5zLXNlcmlmXCIpLFxuICAgICAgICAgICAgZ2V0RmlsbGluZ0ZvbnRTdHlsZTogZmllbGQob3B0aW9ucy5maWxsaW5nRm9udFN0eWxlIHx8IFwibm9ybWFsXCIpLFxuICAgICAgICAgICAgZ2V0RmlsbGluZ0ZvbnRXZWlnaHQ6IGZpZWxkKG9wdGlvbnMuZmlsbGluZ0ZvbnRXZWlnaHQgfHwgXCJub3JtYWxcIiksXG4gICAgICAgICAgICBnZXRGaWxsaW5nUGFkZGluZzogZmllbGQobnVsbCAhPT0gKF9vID0gb3B0aW9ucy5maWxsaW5nUGFkZGluZykgJiYgdm9pZCAwICE9PSBfbyA/IF9vIDogLjQpLFxuICAgICAgICAgICAgZmlsbGluZ1JvdGF0ZUxpc3Q6IG51bGwgIT09IChfcCA9IG9wdGlvbnMuZmlsbGluZ1JvdGF0ZUxpc3QpICYmIHZvaWQgMCAhPT0gX3AgPyBfcCA6IFsgMCwgOTAgXSxcbiAgICAgICAgICAgIGZpbGxpbmdEZWx0YUZvbnRTaXplRmFjdG9yOiBudWxsICE9PSAoX3EgPSBvcHRpb25zLmZpbGxpbmdEZWx0YUZvbnRTaXplRmFjdG9yKSAmJiB2b2lkIDAgIT09IF9xID8gX3EgOiAuMixcbiAgICAgICAgICAgIGZpbGxpbmdDb2xvckxpc3Q6IG9wdGlvbnMuZmlsbGluZ0NvbG9yTGlzdCB8fCBbIFwiIzUzN0VGNVwiIF0sXG4gICAgICAgICAgICBzYW1lQ29sb3JMaXN0OiAhMSxcbiAgICAgICAgICAgIG1pbkluaXRGb250U2l6ZTogbnVsbCAhPT0gKF9yID0gb3B0aW9ucy5taW5Jbml0Rm9udFNpemUpICYmIHZvaWQgMCAhPT0gX3IgPyBfciA6IDEwLFxuICAgICAgICAgICAgbWluRm9udFNpemU6IG51bGwgIT09IChfcyA9IG9wdGlvbnMubWluRm9udFNpemUpICYmIHZvaWQgMCAhPT0gX3MgPyBfcyA6IDQsXG4gICAgICAgICAgICBtaW5GaWxsRm9udFNpemU6IG51bGwgIT09IChfdCA9IG9wdGlvbnMubWluRmlsbEZvbnRTaXplKSAmJiB2b2lkIDAgIT09IF90ID8gX3QgOiAyXG4gICAgICAgIH0sIHNhbWVDb2xvckxpc3QgPSBjb2xvckxpc3RFcXVhbCh3b3Jkc0NvbmZpZy5jb2xvckxpc3QsIGxheW91dENvbmZpZy5maWxsaW5nQ29sb3JMaXN0KTtcbiAgICAgICAgbGF5b3V0Q29uZmlnLnNhbWVDb2xvckxpc3QgPSBzYW1lQ29sb3JMaXN0LCBpbml0Q29sb3JTY2FsZShkYXRhLCB3b3Jkc0NvbmZpZywgbGF5b3V0Q29uZmlnLCBvcHRpb25zKSwgXG4gICAgICAgIGluaXRGaWxsaW5nV29yZHNGb250U2l6ZShkYXRhLCB3b3Jkc0NvbmZpZywgbGF5b3V0Q29uZmlnLCBzZWdtZW50YXRpb25PdXRwdXQpO1xuICAgICAgICBjb25zdCB7Z2V0VGV4dDogZ2V0VGV4dCwgZ2V0Rm9udEZhbWlseTogZ2V0Rm9udEZhbWlseSwgZ2V0Rm9udFN0eWxlOiBnZXRGb250U3R5bGUsIGdldEZvbnRXZWlnaHQ6IGdldEZvbnRXZWlnaHQsIGdldFBhZGRpbmc6IGdldFBhZGRpbmcsIGdldENvbG9yOiBnZXRDb2xvciwgZ2V0RmlsbGluZ0NvbG9yOiBnZXRGaWxsaW5nQ29sb3IsIGdldENvbG9ySGV4OiBnZXRDb2xvckhleCwgZm9udFNpemVTY2FsZTogZm9udFNpemVTY2FsZSwgY29sb3JTY2FsZTogY29sb3JTY2FsZSwgZmlsbGluZ0NvbG9yU2NhbGU6IGZpbGxpbmdDb2xvclNjYWxlLCBnZXRGb250T3BhY2l0eTogZ2V0Rm9udE9wYWNpdHksIHJvdGF0ZUxpc3Q6IHJvdGF0ZUxpc3R9ID0gd29yZHNDb25maWcsIHdvcmRzID0gZGF0YS5tYXAoKGRhdHVtID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICB3ZWlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgdGV4dDogZ2V0VGV4dChkYXR1bSksXG4gICAgICAgICAgICAgICAgZm9udEZhbWlseTogZ2V0Rm9udEZhbWlseShkYXR1bSksXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogZ2V0Rm9udFdlaWdodChkYXR1bSksXG4gICAgICAgICAgICAgICAgZm9udFN0eWxlOiBnZXRGb250U3R5bGUoZGF0dW0pLFxuICAgICAgICAgICAgICAgIHJvdGF0ZTogcm90YXRlTGlzdFt+fihzZWdtZW50YXRpb25JbnB1dC5yYW5kb21HZW5lcmF0b3IoKSAqIHJvdGF0ZUxpc3QubGVuZ3RoKV0sXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IE1hdGgubWF4KGxheW91dENvbmZpZy5taW5Jbml0Rm9udFNpemUsIH5+Zm9udFNpemVTY2FsZShkYXR1bSkpLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IGdldEZvbnRPcGFjaXR5KGRhdHVtKSxcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiBnZXRQYWRkaW5nKGRhdHVtKSxcbiAgICAgICAgICAgICAgICBjb2xvcjogZ2V0Q29sb3JIZXggJiYgZ2V0Q29sb3JIZXgoZGF0dW0pIHx8IGNvbG9yU2NhbGUgJiYgY29sb3JTY2FsZShnZXRDb2xvcihkYXR1bSkpIHx8IFwiYmxhY2tcIixcbiAgICAgICAgICAgICAgICBmaWxsaW5nQ29sb3I6ICFnZXRGaWxsaW5nQ29sb3IgfHwgKG51bGwgPT09IChfYSA9IG9wdGlvbnMuY29sb3JGaWVsZCkgfHwgdm9pZCAwID09PSBfYSA/IHZvaWQgMCA6IF9hLmZpZWxkKSA9PT0gKG51bGwgPT09IChfYiA9IG9wdGlvbnMuZmlsbGluZ0NvbG9yRmllbGQpIHx8IHZvaWQgMCA9PT0gX2IgPyB2b2lkIDAgOiBfYi5maWVsZCkgJiYgc2FtZUNvbG9yTGlzdCA/IHZvaWQgMCA6IGdldENvbG9ySGV4ICYmIGdldENvbG9ySGV4KGRhdHVtKSB8fCBmaWxsaW5nQ29sb3JTY2FsZSAmJiBmaWxsaW5nQ29sb3JTY2FsZShnZXRGaWxsaW5nQ29sb3IoZGF0dW0pKSB8fCBcImJsYWNrXCIsXG4gICAgICAgICAgICAgICAgZGF0dW06IGRhdHVtLFxuICAgICAgICAgICAgICAgIHZpc2libGU6ICEwLFxuICAgICAgICAgICAgICAgIGhhc1BsYWNlZDogITFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKSwgd29yZHNNYXhGb250U2l6ZSA9IG1heEluQXJyYXkod29yZHMubWFwKCh3b3JkID0+IHdvcmQuZm9udFNpemUpKSk7XG4gICAgICAgIHdvcmRzLmZvckVhY2goKHdvcmQgPT4gd29yZC53ZWlnaHQgPSB3b3JkLmZvbnRTaXplIC8gd29yZHNNYXhGb250U2l6ZSkpLCB3b3Jkcy5zb3J0KCgoYSwgYikgPT4gYi53ZWlnaHQgLSBhLndlaWdodCkpO1xuICAgICAgICBjb25zdCB7ZmlsbGluZ1dvcmRzOiBmaWxsaW5nV29yZHMsIHN1Y2Nlc3NlZFdvcmRzOiBzdWNjZXNzZWRXb3JkcywgZmFpbGVkV29yZHM6IGZhaWxlZFdvcmRzfSA9IGNsb3VkKHdvcmRzLCBsYXlvdXRDb25maWcsIHNlZ21lbnRhdGlvbk91dHB1dCksIHRleHRLZXkgPSBudWxsICE9PSAoX3YgPSBudWxsID09PSAoX3UgPSBvcHRpb25zLnRleHQpIHx8IHZvaWQgMCA9PT0gX3UgPyB2b2lkIDAgOiBfdS5maWVsZCkgJiYgdm9pZCAwICE9PSBfdiA/IF92IDogXCJ0ZXh0S2V5XCIsIGRhdGFJbmRleEtleSA9IG51bGwgIT09IChfdyA9IG9wdGlvbnMuZGF0YUluZGV4S2V5KSAmJiB2b2lkIDAgIT09IF93ID8gX3cgOiBcImRlZmF1bHREYXRhSW5kZXhLZXlcIiwgYXMgPSBvcHRpb25zLmFzID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBPVVRQVVQpLCBvcHRpb25zLmFzKSA6IE9VVFBVVDtcbiAgICAgICAgbGV0IHcsIHQ7XG4gICAgICAgIGNvbnN0IG1vZEtleXdvcmRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIHcgPSB3b3Jkc1tpXSwgdCA9IHcuZGF0dW0sIHRbYXMueF0gPSB3LngsIFxuICAgICAgICB0W2FzLnldID0gdy55LCB0W2FzLmZvbnRGYW1pbHldID0gdy5mb250RmFtaWx5LCB0W2FzLmZvbnRTaXplXSA9IHcuZm9udFNpemUsIHRbYXMuZm9udFN0eWxlXSA9IHcuZm9udFN0eWxlLCBcbiAgICAgICAgdFthcy5mb250V2VpZ2h0XSA9IHcuZm9udFdlaWdodCwgdFthcy5hbmdsZV0gPSBkZWdyZWVUb1JhZGlhbih3LnJvdGF0ZSksIHRbYXMub3BhY2l0eV0gPSB3Lm9wYWNpdHksIFxuICAgICAgICB0W2FzLnZpc2libGVdID0gdy52aXNpYmxlLCB0W2FzLmlzRmlsbGluZ1dvcmRdID0gITEsIHRbYXMuY29sb3JdID0gdy5jb2xvciwgdFtkYXRhSW5kZXhLZXldID0gYCR7dy50ZXh0fV8ke2l9X2tleXdvcmRgLCBcbiAgICAgICAgbW9kS2V5d29yZHMucHVzaCh0KTtcbiAgICAgICAgY29uc3QgZmlsbGluZ1dvcmRzRGF0YSA9IFtdO1xuICAgICAgICBpZiAoZmlsbGluZ1dvcmRzLmZvckVhY2goKCh3b3JkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IHQgPSBPYmplY3QuYXNzaWduKHt9LCB3b3JkLmRhdHVtKTtcbiAgICAgICAgICAgIHRbYXMueF0gPSB3b3JkLngsIHRbYXMueV0gPSB3b3JkLnksIHRbYXMuZm9udEZhbWlseV0gPSB3b3JkLmZvbnRGYW1pbHksIHRbYXMuZm9udFNpemVdID0gd29yZC5mb250U2l6ZSwgXG4gICAgICAgICAgICB0W2FzLmZvbnRTdHlsZV0gPSB3b3JkLmZvbnRTdHlsZSwgdFthcy5mb250V2VpZ2h0XSA9IHdvcmQuZm9udFdlaWdodCwgdFthcy5hbmdsZV0gPSBkZWdyZWVUb1JhZGlhbih3b3JkLnJvdGF0ZSksIFxuICAgICAgICAgICAgdFthcy5vcGFjaXR5XSA9IHdvcmQub3BhY2l0eSwgdFthcy52aXNpYmxlXSA9IHdvcmQudmlzaWJsZSwgdFthcy5pc0ZpbGxpbmdXb3JkXSA9ICEwLCBcbiAgICAgICAgICAgIHRbYXMuY29sb3JdID0gZ2V0RmlsbGluZ0NvbG9yID8gKG51bGwgPT09IChfYSA9IG9wdGlvbnMuY29sb3JGaWVsZCkgfHwgdm9pZCAwID09PSBfYSA/IHZvaWQgMCA6IF9hLmZpZWxkKSA9PT0gKG51bGwgPT09IChfYiA9IG9wdGlvbnMuZmlsbGluZ0NvbG9yRmllbGQpIHx8IHZvaWQgMCA9PT0gX2IgPyB2b2lkIDAgOiBfYi5maWVsZCkgJiYgc2FtZUNvbG9yTGlzdCA/IHdvcmQuY29sb3IgOiB3b3JkLmZpbGxpbmdDb2xvciA6IGxheW91dENvbmZpZy5maWxsaW5nQ29sb3JMaXN0W35+KHNlZ21lbnRhdGlvbklucHV0LnJhbmRvbUdlbmVyYXRvcigpICogbGF5b3V0Q29uZmlnLmZpbGxpbmdDb2xvckxpc3QubGVuZ3RoKV0sIFxuICAgICAgICAgICAgdFt0ZXh0S2V5XSA9IHdvcmQudGV4dCwgdFtkYXRhSW5kZXhLZXldID0gYCR7d29yZC50ZXh0fV8ke2luZGV4fV9maWxsaW5nV29yZHNgLCBcbiAgICAgICAgICAgIGZpbGxpbmdXb3Jkc0RhdGEucHVzaCh0KTtcbiAgICAgICAgfSkpLCB0aGlzLnZpZXcgJiYgdGhpcy52aWV3LmVtaXQpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5lbWl0KFdPUkRDTE9VRF9TSEFQRV9IT09LX0VWRU5ULkFGVEVSX1dPUkRDTE9VRF9TSEFQRV9MQVlPVVQsIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzZWRXb3Jkczogc3VjY2Vzc2VkV29yZHMsXG4gICAgICAgICAgICAgICAgZmFpbGVkV29yZHM6IGZhaWxlZFdvcmRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YWdlID0gbnVsbCA9PT0gKF94ID0gdGhpcy52aWV3LnJlbmRlcmVyKSB8fCB2b2lkIDAgPT09IF94ID8gdm9pZCAwIDogX3guc3RhZ2UoKTtcbiAgICAgICAgICAgIHN0YWdlICYmIHN0YWdlLmhvb2tzLmFmdGVyUmVuZGVyLnRhcChXT1JEQ0xPVURfU0hBUEVfSE9PS19FVkVOVC5BRlRFUl9XT1JEQ0xPVURfU0hBUEVfRFJBVywgKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZW1pdChXT1JEQ0xPVURfU0hBUEVfSE9PS19FVkVOVC5BRlRFUl9XT1JEQ0xPVURfU0hBUEVfRFJBVywge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzZWRXb3Jkczogc3VjY2Vzc2VkV29yZHMsXG4gICAgICAgICAgICAgICAgICAgIGZhaWxlZFdvcmRzOiBmYWlsZWRXb3Jkc1xuICAgICAgICAgICAgICAgIH0pLCBzdGFnZS5ob29rcy5hZnRlclJlbmRlci51blRhcChXT1JEQ0xPVURfU0hBUEVfSE9PS19FVkVOVC5BRlRFUl9XT1JEQ0xPVURfU0hBUEVfRFJBVyk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9ncmVzc2l2ZVJlc3VsdCA9IG1vZEtleXdvcmRzLmNvbmNhdChmaWxsaW5nV29yZHNEYXRhKTtcbiAgICB9XG4gICAgcmVsZWFzZSgpIHtcbiAgICAgICAgdGhpcy5zZWdtZW50YXRpb25JbnB1dCA9IG51bGwsIHRoaXMuZGF0YSA9IG51bGwsIHRoaXMucHJvZ3Jlc3NpdmVSZXN1bHQgPSBudWxsLCBcbiAgICAgICAgdGhpcy5vcHRpb25zID0gbnVsbDtcbiAgICB9XG59XG5cbmNvbnN0IGluaXRDb2xvclNjYWxlID0gKGRhdGEsIHdvcmRzQ29uZmlnLCBsYXlvdXRDb25maWcsIG9wdGlvbnMpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgY29uc3Qge2NvbG9yTW9kZTogY29sb3JNb2RlLCBnZXRDb2xvcjogZ2V0Q29sb3IsIGdldEZpbGxpbmdDb2xvcjogZ2V0RmlsbGluZ0NvbG9yfSA9IHdvcmRzQ29uZmlnLCB7c2FtZUNvbG9yTGlzdDogc2FtZUNvbG9yTGlzdH0gPSBsYXlvdXRDb25maWc7XG4gICAgbGV0IGNvbG9yU2NhbGUsIGZpbGxpbmdDb2xvclNjYWxlLCBjb2xvckxpc3QgPSB3b3Jkc0NvbmZpZy5jb2xvckxpc3QsIGZpbGxpbmdDb2xvckxpc3QgPSBsYXlvdXRDb25maWcuZmlsbGluZ0NvbG9yTGlzdDtcbiAgICBpZiAoXCJvcmRpbmFsXCIgPT09IGNvbG9yTW9kZSkge1xuICAgICAgICBjb25zdCB1bmlxdWVDb2xvckZpZWxkID0gZGF0YS5tYXAoKHdvcmQgPT4gZ2V0Q29sb3Iod29yZCkpKTtcbiAgICAgICAgaWYgKGNvbG9yU2NhbGUgPSBkYXR1bSA9PiAobmV3IE9yZGluYWxTY2FsZSkuZG9tYWluKHVuaXF1ZUNvbG9yRmllbGQpLnJhbmdlKGNvbG9yTGlzdCkuc2NhbGUoZGF0dW0pLCBcbiAgICAgICAgZ2V0RmlsbGluZ0NvbG9yICYmICgobnVsbCA9PT0gKF9hID0gb3B0aW9ucy5jb2xvckZpZWxkKSB8fCB2b2lkIDAgPT09IF9hID8gdm9pZCAwIDogX2EuZmllbGQpICE9PSAobnVsbCA9PT0gKF9iID0gb3B0aW9ucy5maWxsaW5nQ29sb3JGaWVsZCkgfHwgdm9pZCAwID09PSBfYiA/IHZvaWQgMCA6IF9iLmZpZWxkKSB8fCAhc2FtZUNvbG9yTGlzdCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZWZpbGxpbmdDb2xvckZpZWxkID0gZGF0YS5tYXAoKGRhdHVtID0+IGdldEZpbGxpbmdDb2xvcihkYXR1bSkpKTtcbiAgICAgICAgICAgIGZpbGxpbmdDb2xvclNjYWxlID0gZGF0dW0gPT4gKG5ldyBPcmRpbmFsU2NhbGUpLmRvbWFpbih1bmlxdWVmaWxsaW5nQ29sb3JGaWVsZCkucmFuZ2UoZmlsbGluZ0NvbG9yTGlzdCkuc2NhbGUoZGF0dW0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgMSA9PT0gY29sb3JMaXN0Lmxlbmd0aCAmJiAoY29sb3JMaXN0ID0gWyBjb2xvckxpc3RbMF0sIGNvbG9yTGlzdFswXSBdKTtcbiAgICAgICAgY29uc3QgdmFsdWVTY2FsZSA9IChuZXcgTGluZWFyU2NhbGUpLmRvbWFpbihleHRlbnQoZ2V0Q29sb3IsIGRhdGEpKS5yYW5nZShjb2xvckxpc3QpO1xuICAgICAgICBpZiAoY29sb3JTY2FsZSA9IGkgPT4gdmFsdWVTY2FsZS5zY2FsZShpKSwgZ2V0RmlsbGluZ0NvbG9yICYmICgobnVsbCA9PT0gKF9jID0gb3B0aW9ucy5jb2xvckZpZWxkKSB8fCB2b2lkIDAgPT09IF9jID8gdm9pZCAwIDogX2MuZmllbGQpICE9PSAobnVsbCA9PT0gKF9kID0gb3B0aW9ucy5maWxsaW5nQ29sb3JGaWVsZCkgfHwgdm9pZCAwID09PSBfZCA/IHZvaWQgMCA6IF9kLmZpZWxkKSB8fCAhc2FtZUNvbG9yTGlzdCkpIHtcbiAgICAgICAgICAgIDEgPT09IGZpbGxpbmdDb2xvckxpc3QubGVuZ3RoICYmIChmaWxsaW5nQ29sb3JMaXN0ID0gWyBmaWxsaW5nQ29sb3JMaXN0WzBdLCBmaWxsaW5nQ29sb3JMaXN0WzBdIF0pO1xuICAgICAgICAgICAgY29uc3QgZmlsbGluZ1ZhbHVlU2NhbGUgPSAobmV3IExpbmVhclNjYWxlKS5kb21haW4oZXh0ZW50KGdldEZpbGxpbmdDb2xvciwgZGF0YSkpLnJhbmdlKGZpbGxpbmdDb2xvckxpc3QpO1xuICAgICAgICAgICAgZmlsbGluZ0NvbG9yU2NhbGUgPSBpID0+IGZpbGxpbmdWYWx1ZVNjYWxlLnNjYWxlKGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24od29yZHNDb25maWcsIHtcbiAgICAgICAgY29sb3JTY2FsZTogY29sb3JTY2FsZSxcbiAgICAgICAgZmlsbGluZ0NvbG9yU2NhbGU6IGZpbGxpbmdDb2xvclNjYWxlXG4gICAgfSk7XG59LCBpbml0Rm9udFNpemVTY2FsZSA9IChkYXRhLCB3b3Jkc0NvbmZpZywgc2VnbWVudGF0aW9uT3V0cHV0KSA9PiB7XG4gICAgbGV0IHtmb250U2l6ZVJhbmdlOiByYW5nZX0gPSB3b3Jkc0NvbmZpZztcbiAgICBjb25zdCB7Z2V0Rm9udFNpemU6IGdldEZvbnRTaXplLCBnZXRUZXh0OiBnZXRUZXh0fSA9IHdvcmRzQ29uZmlnO1xuICAgIGxldCBmb250U2l6ZVNjYWxlO1xuICAgIGlmIChnZXRGb250U2l6ZSkge1xuICAgICAgICBpZiAoZ2V0Rm9udFNpemUgJiYgcmFuZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpemVTY2FsZSA9IChuZXcgU3FydFNjYWxlKS5kb21haW4oZXh0ZW50KGdldEZvbnRTaXplLCBkYXRhKSkucmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgZm9udFNpemVTY2FsZSA9IGRhdHVtID0+IHNpemVTY2FsZS5zY2FsZShnZXRGb250U2l6ZShkYXR1bSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGdldEZvbnRTaXplICYmIGlzRnVuY3Rpb24oZ2V0Rm9udFNpemUpICYmICFyYW5nZSkge1xuICAgICAgICAgICAgY29uc3QgYSA9IC41LCBbbWluLCBtYXhdID0gZXh0ZW50KGdldEZvbnRTaXplLCBkYXRhKSwgd29yZHMgPSBkYXRhLm1hcCgoZGF0dW0gPT4gKHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBnZXRUZXh0KGRhdHVtKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0Rm9udFNpemUoZGF0dW0pLFxuICAgICAgICAgICAgICAgIHdlaWdodDogbWF4ID09PSBtaW4gPyAxIDogKGdldEZvbnRTaXplKGRhdHVtKSAtIG1pbikgLyAobWF4IC0gbWluKVxuICAgICAgICAgICAgfSkpKSwgeCA9IGdldEluaXRpYWxGb250U2l6ZSh3b3Jkcywgc2VnbWVudGF0aW9uT3V0cHV0LCAhMCk7XG4gICAgICAgICAgICByYW5nZSA9IFsgfn4oYSAqIHgpLCB+fnggXTtcbiAgICAgICAgICAgIGNvbnN0IHNpemVTY2FsZSA9IChuZXcgU3FydFNjYWxlKS5kb21haW4oZXh0ZW50KGdldEZvbnRTaXplLCBkYXRhKSkucmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgZm9udFNpemVTY2FsZSA9IGRhdHVtID0+IHNpemVTY2FsZS5zY2FsZShnZXRGb250U2l6ZShkYXR1bSkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgd29yZHMgPSBkYXRhLm1hcCgod29yZCA9PiAoe1xuICAgICAgICAgICAgdGV4dDogZ2V0VGV4dCh3b3JkKVxuICAgICAgICB9KSkpLCB4ID0gZ2V0SW5pdGlhbEZvbnRTaXplKHdvcmRzLCBzZWdtZW50YXRpb25PdXRwdXQsICExKTtcbiAgICAgICAgZm9udFNpemVTY2FsZSA9IGZ1bmN0b3IoeCk7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24od29yZHNDb25maWcsIHtcbiAgICAgICAgZ2V0Rm9udFNpemU6IGdldEZvbnRTaXplLFxuICAgICAgICBmb250U2l6ZVJhbmdlOiByYW5nZSxcbiAgICAgICAgZm9udFNpemVTY2FsZTogZm9udFNpemVTY2FsZVxuICAgIH0pO1xufSwgZ2V0SW5pdGlhbEZvbnRTaXplID0gKHdvcmRzLCBzZWdtZW50YXRpb25PdXRwdXQsIHdlaWdodCkgPT4ge1xuICAgIGNvbnN0IHNoYXBlQXJlYSA9IHNlZ21lbnRhdGlvbk91dHB1dC5zaGFwZUFyZWEsIHJhdGlvID0gc2VnbWVudGF0aW9uT3V0cHV0LnJhdGlvLCByZWdpb25zID0gc2VnbWVudGF0aW9uT3V0cHV0LnNlZ21lbnRhdGlvbi5yZWdpb25zLCBzaGFwZVNpemVMaW1pdFRleHRMZW5ndGggPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KHNoYXBlQXJlYSkgLyAxMiksIHdvcmRBcmVhID0gd29yZHMucmVkdWNlKCgoYWNjLCB3b3JkKSA9PiB7XG4gICAgICAgIGNvbnN0IHRleHRMZW5ndGggPSBjYWxUZXh0TGVuZ3RoKHdvcmQudGV4dCk7XG4gICAgICAgIHJldHVybiB0ZXh0TGVuZ3RoIDwgc2hhcGVTaXplTGltaXRUZXh0TGVuZ3RoID8gYWNjICsgdGV4dExlbmd0aCAqICh3ZWlnaHQgPyAoLjUgKyAuNSAqIHdvcmQud2VpZ2h0KSAqKiAyIDogMSkgOiBhY2M7XG4gICAgfSksIDApO1xuICAgIGlmICgwID09PSB3b3JkQXJlYSkgcmV0dXJuIDEyO1xuICAgIGxldCB4ID0gMjA7XG4gICAgaWYgKDEgPT09IHJlZ2lvbnMubGVuZ3RoKSB4ID0gTWF0aC5zcXJ0KHJhdGlvICogKHNoYXBlQXJlYSAvICgxLjcgKiB3b3JkQXJlYSkpKTsgZWxzZSB7XG4gICAgICAgIGNvbnN0IHhBcnIgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWdpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCByZWdpb25BcmVhID0gcmVnaW9uc1tpXS5hcmVhLCByZWdpb25Bc3BlY3QgPSByZWdpb25zW2ldLnJhdGlvLCByZWdpb25SYXRpbyA9IHJlZ2lvbkFyZWEgLyBzaGFwZUFyZWE7XG4gICAgICAgICAgICBpZiAocmVnaW9uUmF0aW8gPCAuMSkgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCByZWdpb25Xb3JkQXJlYSA9IHJlZ2lvblJhdGlvICogKHdvcmRBcmVhICogKHJlZ2lvbkFzcGVjdCA8IDEgPyAyLjcgLSByZWdpb25Bc3BlY3QgOiAxLjcpKSwgeCA9IE1hdGguc3FydChyYXRpbyAqIChyZWdpb25BcmVhIC8gcmVnaW9uV29yZEFyZWEpKTtcbiAgICAgICAgICAgIHhBcnIucHVzaCh4KTtcbiAgICAgICAgfVxuICAgICAgICB4ID0geEFyci5sZW5ndGggPyBNYXRoLm1pbiguLi54QXJyKSA6IE1hdGguc3FydChyYXRpbyAqIChzaGFwZUFyZWEgLyAoMS43ICogd29yZEFyZWEpKSk7XG4gICAgfVxuICAgIHJldHVybiB4O1xufTtcblxuZnVuY3Rpb24gaW5pdEZpbGxpbmdXb3Jkc0ZvbnRTaXplKGRhdGEsIHdvcmRzQ29uZmlnLCBsYXlvdXRDb25maWcsIHNlZ21lbnRhdGlvbk91dHB1dCkge1xuICAgIGNvbnN0IHtnZXRUZXh0OiBnZXRUZXh0fSA9IHdvcmRzQ29uZmlnO1xuICAgIGxldCB7ZmlsbGluZ0luaXRpYWxGb250U2l6ZTogZmlsbGluZ0luaXRpYWxGb250U2l6ZSwgZmlsbGluZ0RlbHRhRm9udFNpemU6IGZpbGxpbmdEZWx0YUZvbnRTaXplfSA9IGxheW91dENvbmZpZztcbiAgICBjb25zdCB7ZmlsbGluZ1JhdGlvOiBmaWxsaW5nUmF0aW99ID0gbGF5b3V0Q29uZmlnLCBzaGFwZVNpemVMaW1pdFRleHRMZW5ndGggPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KHNlZ21lbnRhdGlvbk91dHB1dC5zaGFwZUFyZWEpIC8gNCk7XG4gICAgaWYgKCFmaWxsaW5nSW5pdGlhbEZvbnRTaXplIHx8ICFmaWxsaW5nRGVsdGFGb250U2l6ZSkge1xuICAgICAgICBjb25zdCBhID0gZmlsbGluZ1JhdGlvIC8gMTAwLCBhdmVyYWdlTGVuZ3RoID0gZGF0YS5yZWR1Y2UoKChhY2MsIHdvcmQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGNhbFRleHRMZW5ndGgoZ2V0VGV4dCh3b3JkKSk7XG4gICAgICAgICAgICByZXR1cm4gbGVuZ3RoID4gc2hhcGVTaXplTGltaXRUZXh0TGVuZ3RoID8gYWNjIDogYWNjICsgbGVuZ3RoO1xuICAgICAgICB9KSwgMCkgLyBkYXRhLmxlbmd0aDtcbiAgICAgICAgbGV0IGZvbnRTaXplO1xuICAgICAgICBpZiAoMCA9PT0gYXZlcmFnZUxlbmd0aCkgZm9udFNpemUgPSA4OyBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGFyZWEgPSAuMiAqIHNlZ21lbnRhdGlvbk91dHB1dC5zaGFwZUFyZWE7XG4gICAgICAgICAgICBmb250U2l6ZSA9IE1hdGguc3FydChhICogKGFyZWEgLyBhdmVyYWdlTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZmlsbGluZ0luaXRpYWxGb250U2l6ZSA9IH5+Zm9udFNpemUsIGZpbGxpbmdEZWx0YUZvbnRTaXplID0gZm9udFNpemUgKiBsYXlvdXRDb25maWcuZmlsbGluZ0RlbHRhRm9udFNpemVGYWN0b3IsIFxuICAgICAgICBPYmplY3QuYXNzaWduKGxheW91dENvbmZpZywge1xuICAgICAgICAgICAgZmlsbGluZ0luaXRpYWxGb250U2l6ZTogZmlsbGluZ0luaXRpYWxGb250U2l6ZSxcbiAgICAgICAgICAgIGZpbGxpbmdEZWx0YUZvbnRTaXplOiBmaWxsaW5nRGVsdGFGb250U2l6ZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNvbnN0IGV4dGVudCA9IChmaWVsZCwgZGF0YSkgPT4ge1xuICAgIGxldCBtaW4gPSAxIC8gMCwgbWF4ID0gLTEgLyAwO1xuICAgIGNvbnN0IG4gPSBkYXRhLmxlbmd0aDtcbiAgICBsZXQgdjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkgdiA9IHRvTnVtYmVyKGZpZWxkKGRhdGFbaV0pKSwgdiA8IG1pbiAmJiAobWluID0gdiksIFxuICAgIHYgPiBtYXggJiYgKG1heCA9IHYpO1xuICAgIHJldHVybiAxID09PSBkYXRhLmxlbmd0aCAmJiBtaW4gPT09IG1heCAmJiAobWluIC09IDFlNCksIFsgbWluLCBtYXggXTtcbn0sIGZpZWxkID0gb3B0aW9uID0+IG9wdGlvbiA/IFwic3RyaW5nXCIgPT0gdHlwZW9mIG9wdGlvbiB8fCBcIm51bWJlclwiID09IHR5cGVvZiBvcHRpb24gPyAoKSA9PiBvcHRpb24gOiBpc0Z1bmN0aW9uKG9wdGlvbikgPyBvcHRpb24gOiBkYXR1bSA9PiBkYXR1bVtvcHRpb24uZmllbGRdIDogbnVsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxheW91dC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/layout.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/segmentation.js":
/*!******************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/segmentation.js ***!
  \******************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allocateWords: () => (/* binding */ allocateWords),\n/* harmony export */   removeBorder: () => (/* binding */ removeBorder),\n/* harmony export */   scaleAndMiddleShape: () => (/* binding */ scaleAndMiddleShape),\n/* harmony export */   segmentation: () => (/* binding */ segmentation)\n/* harmony export */ });\nfunction segmentation(segmentationInput) {\n    const {size: size, maskCanvas: maskCanvas} = segmentationInput, imageData = maskCanvas.getContext(\"2d\", {\n        willReadFrequently: !0\n    }).getImageData(0, 0, maskCanvas.width, maskCanvas.height), labels = new Array(size[0] * size[1]).fill(0);\n    let curLabel = 1;\n    const offset = [ [ 0, 1 ], [ 1, 0 ], [ -1, 0 ], [ 0, -1 ] ];\n    let queue = [];\n    for (let i = 0; i < size[1]; i++) for (let j = 0; j < size[0]; j++) if (0 === labels[i * size[0] + j] && !segmentationInput.isEmptyPixel(imageData, i, j)) {\n        labels[i * size[0] + j] = curLabel, queue.push([ i, j ]);\n        for (let k = 0; k < queue.length; k++) for (let m = 0; m < 4; m++) {\n            let row = queue[k][0] + offset[m][0], col = queue[k][1] + offset[m][1];\n            row = row < 0 ? 0 : row >= size[1] ? size[1] - 1 : row, col = col < 0 ? 0 : col >= size[0] ? size[0] - 1 : col, \n            0 !== labels[row * size[0] + col] || segmentationInput.isEmptyPixel(imageData, row, col) || (labels[row * size[0] + col] = curLabel, \n            queue.push([ row, col ]));\n        }\n        curLabel++, queue = [];\n    }\n    const boundaries = {}, areas = {}, centers = {}, maxPoints = {}, maxR = {}, ratios = {}, shapeBounds = {\n        x1: 1 / 0,\n        x2: -1 / 0,\n        y1: 1 / 0,\n        y2: -1 / 0,\n        width: 0,\n        height: 0\n    };\n    for (let i = 0; i < size[1]; i++) for (let j = 0; j < size[0]; j++) {\n        const label = labels[i * size[0] + j];\n        0 !== label && (isBoundaryPixel(i, j) && (boundaries[label] = boundaries[label] || [], \n        boundaries[label].push([ j, i ]), maxPoints[label] || (maxPoints[label] = [ 1 / 0, -1 / 0, 1 / 0, -1 / 0 ]), \n        i < maxPoints[label][0] && (maxPoints[label][0] = i), i > maxPoints[label][1] && (maxPoints[label][1] = i), \n        j < maxPoints[label][2] && (maxPoints[label][2] = j), j > maxPoints[label][3] && (maxPoints[label][3] = j), \n        j < shapeBounds.x1 && (shapeBounds.x1 = j), j > shapeBounds.x2 && (shapeBounds.x2 = j), \n        i < shapeBounds.y1 && (shapeBounds.y1 = i), i > shapeBounds.y2 && (shapeBounds.y2 = i)), \n        areas[label] = areas[label] || 0, areas[label]++);\n    }\n    const allBoundaries = [];\n    for (const label in boundaries) {\n        const boundary = boundaries[label], x = ~~(boundary.reduce(((acc, cur) => acc + cur[0]), 0) / boundary.length), y = ~~(boundary.reduce(((acc, cur) => acc + cur[1]), 0) / boundary.length);\n        centers[label] = [ x, y ], allBoundaries.push(...boundary);\n        const [yMin, yMax, xMin, xMax] = maxPoints[label];\n        maxR[label] = ~~Math.max(Math.sqrt((x - xMin) ** 2 + (y - yMin) ** 2), Math.sqrt((x - xMax) ** 2 + (y - yMax) ** 2), Math.sqrt((x - xMin) ** 2 + (y - yMax) ** 2), Math.sqrt((x - xMax) ** 2 + (y - yMin) ** 2)), \n        ratios[label] = (xMax - xMin) / (yMax - yMin);\n    }\n    const regions = Object.keys(centers).map((key => ({\n        label: key - 1,\n        boundary: boundaries[key],\n        area: areas[key],\n        center: centers[key],\n        maxPoint: maxPoints[key],\n        maxR: maxR[key],\n        ratio: ratios[key]\n    })));\n    shapeBounds.width = shapeBounds.x2 - shapeBounds.x1 + 1, shapeBounds.height = shapeBounds.y2 - shapeBounds.y1 + 1;\n    const x = ~~(allBoundaries.reduce(((acc, cur) => acc + cur[0]), 0) / allBoundaries.length), y = ~~(allBoundaries.reduce(((acc, cur) => acc + cur[1]), 0) / allBoundaries.length), shapeMaxR = ~~Math.max(Math.sqrt((x - shapeBounds.x1) ** 2 + (y - shapeBounds.y1) ** 2), Math.sqrt((x - shapeBounds.x2) ** 2 + (y - shapeBounds.y2) ** 2), Math.sqrt((x - shapeBounds.x1) ** 2 + (y - shapeBounds.y2) ** 2), Math.sqrt((x - shapeBounds.x2) ** 2 + (y - shapeBounds.y1) ** 2)), shapeRatio = shapeBounds.width / shapeBounds.height, shapeArea = Object.keys(areas).reduce(((acc, key) => acc + areas[key]), 0), segmentation = {\n        regions: regions,\n        labels: labels,\n        labelNumber: curLabel - 1\n    };\n    return Object.assign(segmentationInput, {\n        segmentation: segmentation,\n        shapeBounds: shapeBounds,\n        shapeMaxR: shapeMaxR,\n        shapeRatio: shapeRatio,\n        shapeCenter: [ x, y ],\n        shapeArea: shapeArea\n    });\n    function isBoundaryPixel(i, j) {\n        const offset = [ [ 0, 1 ], [ 1, 0 ], [ -1, 0 ], [ 0, -1 ] ];\n        if (0 === i || 0 === j || i === size[1] - 1 || j === size[0] - 1) return !0;\n        for (let k = 0; k < 4; k++) {\n            let row = i + offset[k][0], col = j + offset[k][1];\n            if (row = row < 0 ? 0 : row >= size[1] ? size[1] - 1 : row, col = col < 0 ? 0 : col >= size[0] ? size[0] - 1 : col, \n            0 === labels[row * size[0] + col]) return !0;\n        }\n        return !1;\n    }\n}\n\nfunction removeBorder(image, canvas, isEmptyPixel) {\n    canvas.width = image.width, canvas.height = image.height;\n    const ctx = canvas.getContext(\"2d\", {\n        willReadFrequently: !0\n    });\n    ctx.clearRect(0, 0, canvas.width, canvas.height), ctx.drawImage(image, 0, 0);\n    const width = canvas.width, imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    let top = 0, bottom = imageData.height, left = 0, right = imageData.width;\n    const rowBlank = (width, y) => {\n        for (let x = 0; x < width; ++x) if (!isEmptyPixel(imageData, y, x)) return !1;\n        return !0;\n    }, columnBlank = (x, y0, y1) => {\n        for (let y = y0; y < y1; ++y) if (!isEmptyPixel(imageData, y, x)) return !1;\n        return !0;\n    };\n    for (;top < bottom && rowBlank(width, top); ) ++top;\n    for (;bottom - 1 > top && rowBlank(width, bottom - 1); ) --bottom;\n    for (;left < right && columnBlank(left, top, bottom); ) ++left;\n    for (;right - 1 > left && columnBlank(right - 1, top, bottom); ) --right;\n    const trimmed = ctx.getImageData(left, top, right - left, bottom - top);\n    return canvas.width = trimmed.width, canvas.height = trimmed.height, ctx.clearRect(0, 0, canvas.width, canvas.height), \n    ctx.putImageData(trimmed, 0, 0), canvas;\n}\n\nfunction scaleAndMiddleShape(image, size) {\n    const width = image.width, height = image.height;\n    let scale = size[0] / width;\n    height * scale > size[1] && (scale = size[1] / height);\n    const newWidth = Math.floor(scale * width), newHeight = Math.floor(scale * height);\n    return {\n        x: (size[0] - newWidth) / 2,\n        y: (size[1] - newHeight) / 2,\n        width: newWidth,\n        height: newHeight,\n        scale: scale\n    };\n}\n\nfunction allocateWords(words, segmentationOutput) {\n    const {segmentation: {regions: regions}} = segmentationOutput;\n    let areaMax = -1 / 0, totalArea = 0, areaMaxIndex = 0;\n    regions.forEach(((region, index) => {\n        const area = region.area;\n        area > areaMax && (areaMax = area, areaMaxIndex = index), totalArea += area;\n    }));\n    let wordsSum = 0;\n    regions.forEach((region => {\n        const area = region.area, regionNum = Math.ceil(area / totalArea * words.length), regionWeight = area / areaMax;\n        region.words = [], region.regionNum = regionNum, region.regionWeight = regionWeight, \n        wordsSum += regionNum;\n    })), wordsSum < words.length && (regions[areaMaxIndex].wordsNum += words.length - wordsSum);\n    let currIndex = areaMaxIndex;\n    const regionNums = regions.map((region => region.regionNum));\n    words.forEach((word => {\n        let failCounter = 0, updateCounter = 0;\n        word.regionIndex = -1;\n        do {\n            if (regionNums[currIndex] > 0 && word.weight <= regions[currIndex].regionWeight) {\n                word.regionIndex = currIndex, regions[currIndex].words.push(word), regionNums[currIndex]--, \n                currIndex = (currIndex + 1) % regions.length;\n                break;\n            }\n            currIndex = (currIndex + 1) % regions.length, failCounter++, updateCounter++, updateCounter > regions.length + 1 && (regions.forEach((region => {\n                region.regionWeight += .15;\n            })), updateCounter = 0);\n        } while (-1 === word.regionIndex && failCounter < 3 * regions.length);\n        -1 === word.regionIndex && (word.regionIndex = areaMaxIndex, regions[areaMaxIndex].words.push(word), \n        regionNums[areaMaxIndex]--);\n    })), regions.forEach((region => {\n        region.words.sort(((a, b) => b.weight - a.weight));\n    }));\n}\n//# sourceMappingURL=segmentation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZUAwLjE0LjEzL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItd29yZGNsb3VkLXNoYXBlL2VzL3NlZ21lbnRhdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQU87QUFDUCxXQUFXLG9DQUFvQztBQUMvQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYSxxQkFBcUIsYUFBYTtBQUNuRTtBQUNBLHdCQUF3QixrQkFBa0IscUJBQXFCLE9BQU87QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWSxjQUFjLGdCQUFnQixXQUFXLGFBQWE7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYSxxQkFBcUIsYUFBYTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0EsS0FBSztBQUNMLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQSxVQUFVLHNDQUFzQztBQUNoRCxVQUFVLGlEQUFpRDtBQUMzRCxVQUFVLGdEQUFnRDtBQUMxRCxVQUFVLHlEQUF5RDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLFdBQVcsZUFBZSxtQkFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnlubGF0aWNzLWFpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B2aXNhY3Rvcit2Z3JhbW1hci13b3JkY2xvdWQtc2hhcGVAMC4xNC4xMy9ub2RlX21vZHVsZXMvQHZpc2FjdG9yL3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZS9lcy9zZWdtZW50YXRpb24uanM/NmYyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gc2VnbWVudGF0aW9uKHNlZ21lbnRhdGlvbklucHV0KSB7XG4gICAgY29uc3Qge3NpemU6IHNpemUsIG1hc2tDYW52YXM6IG1hc2tDYW52YXN9ID0gc2VnbWVudGF0aW9uSW5wdXQsIGltYWdlRGF0YSA9IG1hc2tDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiAhMFxuICAgIH0pLmdldEltYWdlRGF0YSgwLCAwLCBtYXNrQ2FudmFzLndpZHRoLCBtYXNrQ2FudmFzLmhlaWdodCksIGxhYmVscyA9IG5ldyBBcnJheShzaXplWzBdICogc2l6ZVsxXSkuZmlsbCgwKTtcbiAgICBsZXQgY3VyTGFiZWwgPSAxO1xuICAgIGNvbnN0IG9mZnNldCA9IFsgWyAwLCAxIF0sIFsgMSwgMCBdLCBbIC0xLCAwIF0sIFsgMCwgLTEgXSBdO1xuICAgIGxldCBxdWV1ZSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZVsxXTsgaSsrKSBmb3IgKGxldCBqID0gMDsgaiA8IHNpemVbMF07IGorKykgaWYgKDAgPT09IGxhYmVsc1tpICogc2l6ZVswXSArIGpdICYmICFzZWdtZW50YXRpb25JbnB1dC5pc0VtcHR5UGl4ZWwoaW1hZ2VEYXRhLCBpLCBqKSkge1xuICAgICAgICBsYWJlbHNbaSAqIHNpemVbMF0gKyBqXSA9IGN1ckxhYmVsLCBxdWV1ZS5wdXNoKFsgaSwgaiBdKTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBxdWV1ZS5sZW5ndGg7IGsrKykgZm9yIChsZXQgbSA9IDA7IG0gPCA0OyBtKyspIHtcbiAgICAgICAgICAgIGxldCByb3cgPSBxdWV1ZVtrXVswXSArIG9mZnNldFttXVswXSwgY29sID0gcXVldWVba11bMV0gKyBvZmZzZXRbbV1bMV07XG4gICAgICAgICAgICByb3cgPSByb3cgPCAwID8gMCA6IHJvdyA+PSBzaXplWzFdID8gc2l6ZVsxXSAtIDEgOiByb3csIGNvbCA9IGNvbCA8IDAgPyAwIDogY29sID49IHNpemVbMF0gPyBzaXplWzBdIC0gMSA6IGNvbCwgXG4gICAgICAgICAgICAwICE9PSBsYWJlbHNbcm93ICogc2l6ZVswXSArIGNvbF0gfHwgc2VnbWVudGF0aW9uSW5wdXQuaXNFbXB0eVBpeGVsKGltYWdlRGF0YSwgcm93LCBjb2wpIHx8IChsYWJlbHNbcm93ICogc2l6ZVswXSArIGNvbF0gPSBjdXJMYWJlbCwgXG4gICAgICAgICAgICBxdWV1ZS5wdXNoKFsgcm93LCBjb2wgXSkpO1xuICAgICAgICB9XG4gICAgICAgIGN1ckxhYmVsKyssIHF1ZXVlID0gW107XG4gICAgfVxuICAgIGNvbnN0IGJvdW5kYXJpZXMgPSB7fSwgYXJlYXMgPSB7fSwgY2VudGVycyA9IHt9LCBtYXhQb2ludHMgPSB7fSwgbWF4UiA9IHt9LCByYXRpb3MgPSB7fSwgc2hhcGVCb3VuZHMgPSB7XG4gICAgICAgIHgxOiAxIC8gMCxcbiAgICAgICAgeDI6IC0xIC8gMCxcbiAgICAgICAgeTE6IDEgLyAwLFxuICAgICAgICB5MjogLTEgLyAwLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemVbMV07IGkrKykgZm9yIChsZXQgaiA9IDA7IGogPCBzaXplWzBdOyBqKyspIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBsYWJlbHNbaSAqIHNpemVbMF0gKyBqXTtcbiAgICAgICAgMCAhPT0gbGFiZWwgJiYgKGlzQm91bmRhcnlQaXhlbChpLCBqKSAmJiAoYm91bmRhcmllc1tsYWJlbF0gPSBib3VuZGFyaWVzW2xhYmVsXSB8fCBbXSwgXG4gICAgICAgIGJvdW5kYXJpZXNbbGFiZWxdLnB1c2goWyBqLCBpIF0pLCBtYXhQb2ludHNbbGFiZWxdIHx8IChtYXhQb2ludHNbbGFiZWxdID0gWyAxIC8gMCwgLTEgLyAwLCAxIC8gMCwgLTEgLyAwIF0pLCBcbiAgICAgICAgaSA8IG1heFBvaW50c1tsYWJlbF1bMF0gJiYgKG1heFBvaW50c1tsYWJlbF1bMF0gPSBpKSwgaSA+IG1heFBvaW50c1tsYWJlbF1bMV0gJiYgKG1heFBvaW50c1tsYWJlbF1bMV0gPSBpKSwgXG4gICAgICAgIGogPCBtYXhQb2ludHNbbGFiZWxdWzJdICYmIChtYXhQb2ludHNbbGFiZWxdWzJdID0gaiksIGogPiBtYXhQb2ludHNbbGFiZWxdWzNdICYmIChtYXhQb2ludHNbbGFiZWxdWzNdID0gaiksIFxuICAgICAgICBqIDwgc2hhcGVCb3VuZHMueDEgJiYgKHNoYXBlQm91bmRzLngxID0gaiksIGogPiBzaGFwZUJvdW5kcy54MiAmJiAoc2hhcGVCb3VuZHMueDIgPSBqKSwgXG4gICAgICAgIGkgPCBzaGFwZUJvdW5kcy55MSAmJiAoc2hhcGVCb3VuZHMueTEgPSBpKSwgaSA+IHNoYXBlQm91bmRzLnkyICYmIChzaGFwZUJvdW5kcy55MiA9IGkpKSwgXG4gICAgICAgIGFyZWFzW2xhYmVsXSA9IGFyZWFzW2xhYmVsXSB8fCAwLCBhcmVhc1tsYWJlbF0rKyk7XG4gICAgfVxuICAgIGNvbnN0IGFsbEJvdW5kYXJpZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGxhYmVsIGluIGJvdW5kYXJpZXMpIHtcbiAgICAgICAgY29uc3QgYm91bmRhcnkgPSBib3VuZGFyaWVzW2xhYmVsXSwgeCA9IH5+KGJvdW5kYXJ5LnJlZHVjZSgoKGFjYywgY3VyKSA9PiBhY2MgKyBjdXJbMF0pLCAwKSAvIGJvdW5kYXJ5Lmxlbmd0aCksIHkgPSB+fihib3VuZGFyeS5yZWR1Y2UoKChhY2MsIGN1cikgPT4gYWNjICsgY3VyWzFdKSwgMCkgLyBib3VuZGFyeS5sZW5ndGgpO1xuICAgICAgICBjZW50ZXJzW2xhYmVsXSA9IFsgeCwgeSBdLCBhbGxCb3VuZGFyaWVzLnB1c2goLi4uYm91bmRhcnkpO1xuICAgICAgICBjb25zdCBbeU1pbiwgeU1heCwgeE1pbiwgeE1heF0gPSBtYXhQb2ludHNbbGFiZWxdO1xuICAgICAgICBtYXhSW2xhYmVsXSA9IH5+TWF0aC5tYXgoTWF0aC5zcXJ0KCh4IC0geE1pbikgKiogMiArICh5IC0geU1pbikgKiogMiksIE1hdGguc3FydCgoeCAtIHhNYXgpICoqIDIgKyAoeSAtIHlNYXgpICoqIDIpLCBNYXRoLnNxcnQoKHggLSB4TWluKSAqKiAyICsgKHkgLSB5TWF4KSAqKiAyKSwgTWF0aC5zcXJ0KCh4IC0geE1heCkgKiogMiArICh5IC0geU1pbikgKiogMikpLCBcbiAgICAgICAgcmF0aW9zW2xhYmVsXSA9ICh4TWF4IC0geE1pbikgLyAoeU1heCAtIHlNaW4pO1xuICAgIH1cbiAgICBjb25zdCByZWdpb25zID0gT2JqZWN0LmtleXMoY2VudGVycykubWFwKChrZXkgPT4gKHtcbiAgICAgICAgbGFiZWw6IGtleSAtIDEsXG4gICAgICAgIGJvdW5kYXJ5OiBib3VuZGFyaWVzW2tleV0sXG4gICAgICAgIGFyZWE6IGFyZWFzW2tleV0sXG4gICAgICAgIGNlbnRlcjogY2VudGVyc1trZXldLFxuICAgICAgICBtYXhQb2ludDogbWF4UG9pbnRzW2tleV0sXG4gICAgICAgIG1heFI6IG1heFJba2V5XSxcbiAgICAgICAgcmF0aW86IHJhdGlvc1trZXldXG4gICAgfSkpKTtcbiAgICBzaGFwZUJvdW5kcy53aWR0aCA9IHNoYXBlQm91bmRzLngyIC0gc2hhcGVCb3VuZHMueDEgKyAxLCBzaGFwZUJvdW5kcy5oZWlnaHQgPSBzaGFwZUJvdW5kcy55MiAtIHNoYXBlQm91bmRzLnkxICsgMTtcbiAgICBjb25zdCB4ID0gfn4oYWxsQm91bmRhcmllcy5yZWR1Y2UoKChhY2MsIGN1cikgPT4gYWNjICsgY3VyWzBdKSwgMCkgLyBhbGxCb3VuZGFyaWVzLmxlbmd0aCksIHkgPSB+fihhbGxCb3VuZGFyaWVzLnJlZHVjZSgoKGFjYywgY3VyKSA9PiBhY2MgKyBjdXJbMV0pLCAwKSAvIGFsbEJvdW5kYXJpZXMubGVuZ3RoKSwgc2hhcGVNYXhSID0gfn5NYXRoLm1heChNYXRoLnNxcnQoKHggLSBzaGFwZUJvdW5kcy54MSkgKiogMiArICh5IC0gc2hhcGVCb3VuZHMueTEpICoqIDIpLCBNYXRoLnNxcnQoKHggLSBzaGFwZUJvdW5kcy54MikgKiogMiArICh5IC0gc2hhcGVCb3VuZHMueTIpICoqIDIpLCBNYXRoLnNxcnQoKHggLSBzaGFwZUJvdW5kcy54MSkgKiogMiArICh5IC0gc2hhcGVCb3VuZHMueTIpICoqIDIpLCBNYXRoLnNxcnQoKHggLSBzaGFwZUJvdW5kcy54MikgKiogMiArICh5IC0gc2hhcGVCb3VuZHMueTEpICoqIDIpKSwgc2hhcGVSYXRpbyA9IHNoYXBlQm91bmRzLndpZHRoIC8gc2hhcGVCb3VuZHMuaGVpZ2h0LCBzaGFwZUFyZWEgPSBPYmplY3Qua2V5cyhhcmVhcykucmVkdWNlKCgoYWNjLCBrZXkpID0+IGFjYyArIGFyZWFzW2tleV0pLCAwKSwgc2VnbWVudGF0aW9uID0ge1xuICAgICAgICByZWdpb25zOiByZWdpb25zLFxuICAgICAgICBsYWJlbHM6IGxhYmVscyxcbiAgICAgICAgbGFiZWxOdW1iZXI6IGN1ckxhYmVsIC0gMVxuICAgIH07XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oc2VnbWVudGF0aW9uSW5wdXQsIHtcbiAgICAgICAgc2VnbWVudGF0aW9uOiBzZWdtZW50YXRpb24sXG4gICAgICAgIHNoYXBlQm91bmRzOiBzaGFwZUJvdW5kcyxcbiAgICAgICAgc2hhcGVNYXhSOiBzaGFwZU1heFIsXG4gICAgICAgIHNoYXBlUmF0aW86IHNoYXBlUmF0aW8sXG4gICAgICAgIHNoYXBlQ2VudGVyOiBbIHgsIHkgXSxcbiAgICAgICAgc2hhcGVBcmVhOiBzaGFwZUFyZWFcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBpc0JvdW5kYXJ5UGl4ZWwoaSwgaikge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBbIFsgMCwgMSBdLCBbIDEsIDAgXSwgWyAtMSwgMCBdLCBbIDAsIC0xIF0gXTtcbiAgICAgICAgaWYgKDAgPT09IGkgfHwgMCA9PT0gaiB8fCBpID09PSBzaXplWzFdIC0gMSB8fCBqID09PSBzaXplWzBdIC0gMSkgcmV0dXJuICEwO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IDQ7IGsrKykge1xuICAgICAgICAgICAgbGV0IHJvdyA9IGkgKyBvZmZzZXRba11bMF0sIGNvbCA9IGogKyBvZmZzZXRba11bMV07XG4gICAgICAgICAgICBpZiAocm93ID0gcm93IDwgMCA/IDAgOiByb3cgPj0gc2l6ZVsxXSA/IHNpemVbMV0gLSAxIDogcm93LCBjb2wgPSBjb2wgPCAwID8gMCA6IGNvbCA+PSBzaXplWzBdID8gc2l6ZVswXSAtIDEgOiBjb2wsIFxuICAgICAgICAgICAgMCA9PT0gbGFiZWxzW3JvdyAqIHNpemVbMF0gKyBjb2xdKSByZXR1cm4gITA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICExO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUJvcmRlcihpbWFnZSwgY2FudmFzLCBpc0VtcHR5UGl4ZWwpIHtcbiAgICBjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aCwgY2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiAhMFxuICAgIH0pO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KSwgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XG4gICAgY29uc3Qgd2lkdGggPSBjYW52YXMud2lkdGgsIGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBsZXQgdG9wID0gMCwgYm90dG9tID0gaW1hZ2VEYXRhLmhlaWdodCwgbGVmdCA9IDAsIHJpZ2h0ID0gaW1hZ2VEYXRhLndpZHRoO1xuICAgIGNvbnN0IHJvd0JsYW5rID0gKHdpZHRoLCB5KSA9PiB7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7ICsreCkgaWYgKCFpc0VtcHR5UGl4ZWwoaW1hZ2VEYXRhLCB5LCB4KSkgcmV0dXJuICExO1xuICAgICAgICByZXR1cm4gITA7XG4gICAgfSwgY29sdW1uQmxhbmsgPSAoeCwgeTAsIHkxKSA9PiB7XG4gICAgICAgIGZvciAobGV0IHkgPSB5MDsgeSA8IHkxOyArK3kpIGlmICghaXNFbXB0eVBpeGVsKGltYWdlRGF0YSwgeSwgeCkpIHJldHVybiAhMTtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgIH07XG4gICAgZm9yICg7dG9wIDwgYm90dG9tICYmIHJvd0JsYW5rKHdpZHRoLCB0b3ApOyApICsrdG9wO1xuICAgIGZvciAoO2JvdHRvbSAtIDEgPiB0b3AgJiYgcm93Qmxhbmsod2lkdGgsIGJvdHRvbSAtIDEpOyApIC0tYm90dG9tO1xuICAgIGZvciAoO2xlZnQgPCByaWdodCAmJiBjb2x1bW5CbGFuayhsZWZ0LCB0b3AsIGJvdHRvbSk7ICkgKytsZWZ0O1xuICAgIGZvciAoO3JpZ2h0IC0gMSA+IGxlZnQgJiYgY29sdW1uQmxhbmsocmlnaHQgLSAxLCB0b3AsIGJvdHRvbSk7ICkgLS1yaWdodDtcbiAgICBjb25zdCB0cmltbWVkID0gY3R4LmdldEltYWdlRGF0YShsZWZ0LCB0b3AsIHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wKTtcbiAgICByZXR1cm4gY2FudmFzLndpZHRoID0gdHJpbW1lZC53aWR0aCwgY2FudmFzLmhlaWdodCA9IHRyaW1tZWQuaGVpZ2h0LCBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCksIFxuICAgIGN0eC5wdXRJbWFnZURhdGEodHJpbW1lZCwgMCwgMCksIGNhbnZhcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlQW5kTWlkZGxlU2hhcGUoaW1hZ2UsIHNpemUpIHtcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlLndpZHRoLCBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgbGV0IHNjYWxlID0gc2l6ZVswXSAvIHdpZHRoO1xuICAgIGhlaWdodCAqIHNjYWxlID4gc2l6ZVsxXSAmJiAoc2NhbGUgPSBzaXplWzFdIC8gaGVpZ2h0KTtcbiAgICBjb25zdCBuZXdXaWR0aCA9IE1hdGguZmxvb3Ioc2NhbGUgKiB3aWR0aCksIG5ld0hlaWdodCA9IE1hdGguZmxvb3Ioc2NhbGUgKiBoZWlnaHQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IChzaXplWzBdIC0gbmV3V2lkdGgpIC8gMixcbiAgICAgICAgeTogKHNpemVbMV0gLSBuZXdIZWlnaHQpIC8gMixcbiAgICAgICAgd2lkdGg6IG5ld1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IG5ld0hlaWdodCxcbiAgICAgICAgc2NhbGU6IHNjYWxlXG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFsbG9jYXRlV29yZHMod29yZHMsIHNlZ21lbnRhdGlvbk91dHB1dCkge1xuICAgIGNvbnN0IHtzZWdtZW50YXRpb246IHtyZWdpb25zOiByZWdpb25zfX0gPSBzZWdtZW50YXRpb25PdXRwdXQ7XG4gICAgbGV0IGFyZWFNYXggPSAtMSAvIDAsIHRvdGFsQXJlYSA9IDAsIGFyZWFNYXhJbmRleCA9IDA7XG4gICAgcmVnaW9ucy5mb3JFYWNoKCgocmVnaW9uLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBhcmVhID0gcmVnaW9uLmFyZWE7XG4gICAgICAgIGFyZWEgPiBhcmVhTWF4ICYmIChhcmVhTWF4ID0gYXJlYSwgYXJlYU1heEluZGV4ID0gaW5kZXgpLCB0b3RhbEFyZWEgKz0gYXJlYTtcbiAgICB9KSk7XG4gICAgbGV0IHdvcmRzU3VtID0gMDtcbiAgICByZWdpb25zLmZvckVhY2goKHJlZ2lvbiA9PiB7XG4gICAgICAgIGNvbnN0IGFyZWEgPSByZWdpb24uYXJlYSwgcmVnaW9uTnVtID0gTWF0aC5jZWlsKGFyZWEgLyB0b3RhbEFyZWEgKiB3b3Jkcy5sZW5ndGgpLCByZWdpb25XZWlnaHQgPSBhcmVhIC8gYXJlYU1heDtcbiAgICAgICAgcmVnaW9uLndvcmRzID0gW10sIHJlZ2lvbi5yZWdpb25OdW0gPSByZWdpb25OdW0sIHJlZ2lvbi5yZWdpb25XZWlnaHQgPSByZWdpb25XZWlnaHQsIFxuICAgICAgICB3b3Jkc1N1bSArPSByZWdpb25OdW07XG4gICAgfSkpLCB3b3Jkc1N1bSA8IHdvcmRzLmxlbmd0aCAmJiAocmVnaW9uc1thcmVhTWF4SW5kZXhdLndvcmRzTnVtICs9IHdvcmRzLmxlbmd0aCAtIHdvcmRzU3VtKTtcbiAgICBsZXQgY3VyckluZGV4ID0gYXJlYU1heEluZGV4O1xuICAgIGNvbnN0IHJlZ2lvbk51bXMgPSByZWdpb25zLm1hcCgocmVnaW9uID0+IHJlZ2lvbi5yZWdpb25OdW0pKTtcbiAgICB3b3Jkcy5mb3JFYWNoKCh3b3JkID0+IHtcbiAgICAgICAgbGV0IGZhaWxDb3VudGVyID0gMCwgdXBkYXRlQ291bnRlciA9IDA7XG4gICAgICAgIHdvcmQucmVnaW9uSW5kZXggPSAtMTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKHJlZ2lvbk51bXNbY3VyckluZGV4XSA+IDAgJiYgd29yZC53ZWlnaHQgPD0gcmVnaW9uc1tjdXJySW5kZXhdLnJlZ2lvbldlaWdodCkge1xuICAgICAgICAgICAgICAgIHdvcmQucmVnaW9uSW5kZXggPSBjdXJySW5kZXgsIHJlZ2lvbnNbY3VyckluZGV4XS53b3Jkcy5wdXNoKHdvcmQpLCByZWdpb25OdW1zW2N1cnJJbmRleF0tLSwgXG4gICAgICAgICAgICAgICAgY3VyckluZGV4ID0gKGN1cnJJbmRleCArIDEpICUgcmVnaW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJySW5kZXggPSAoY3VyckluZGV4ICsgMSkgJSByZWdpb25zLmxlbmd0aCwgZmFpbENvdW50ZXIrKywgdXBkYXRlQ291bnRlcisrLCB1cGRhdGVDb3VudGVyID4gcmVnaW9ucy5sZW5ndGggKyAxICYmIChyZWdpb25zLmZvckVhY2goKHJlZ2lvbiA9PiB7XG4gICAgICAgICAgICAgICAgcmVnaW9uLnJlZ2lvbldlaWdodCArPSAuMTU7XG4gICAgICAgICAgICB9KSksIHVwZGF0ZUNvdW50ZXIgPSAwKTtcbiAgICAgICAgfSB3aGlsZSAoLTEgPT09IHdvcmQucmVnaW9uSW5kZXggJiYgZmFpbENvdW50ZXIgPCAzICogcmVnaW9ucy5sZW5ndGgpO1xuICAgICAgICAtMSA9PT0gd29yZC5yZWdpb25JbmRleCAmJiAod29yZC5yZWdpb25JbmRleCA9IGFyZWFNYXhJbmRleCwgcmVnaW9uc1thcmVhTWF4SW5kZXhdLndvcmRzLnB1c2god29yZCksIFxuICAgICAgICByZWdpb25OdW1zW2FyZWFNYXhJbmRleF0tLSk7XG4gICAgfSkpLCByZWdpb25zLmZvckVhY2goKHJlZ2lvbiA9PiB7XG4gICAgICAgIHJlZ2lvbi53b3Jkcy5zb3J0KCgoYSwgYikgPT4gYi53ZWlnaHQgLSBhLndlaWdodCkpO1xuICAgIH0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlZ21lbnRhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/segmentation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/util.js":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/util.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WORDCLOUD_SHAPE_HOOK_EVENT: () => (/* binding */ WORDCLOUD_SHAPE_HOOK_EVENT),\n/* harmony export */   calTextLength: () => (/* binding */ calTextLength),\n/* harmony export */   colorListEqual: () => (/* binding */ colorListEqual),\n/* harmony export */   draw: () => (/* binding */ draw),\n/* harmony export */   drawSpiral: () => (/* binding */ drawSpiral),\n/* harmony export */   fakeRandom: () => (/* binding */ fakeRandom),\n/* harmony export */   functor: () => (/* binding */ functor),\n/* harmony export */   isChinese: () => (/* binding */ isChinese),\n/* harmony export */   loadImage: () => (/* binding */ loadImage),\n/* harmony export */   paint: () => (/* binding */ paint),\n/* harmony export */   paintLabels: () => (/* binding */ paintLabels)\n/* harmony export */ });\n/* harmony import */ var _visactor_vrender_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @visactor/vrender-core */ \"(ssr)/./node_modules/.pnpm/@visactor+vrender-core@0.20.12/node_modules/@visactor/vrender-core/es/graphic/image.js\");\n/* harmony import */ var _visactor_vrender_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @visactor/vrender-core */ \"(ssr)/./node_modules/.pnpm/@visactor+vrender-core@0.20.12/node_modules/@visactor/vrender-core/es/modules.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.18.18/node_modules/@visactor/vutils/es/common/isNil.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.18.18/node_modules/@visactor/vutils/es/common/isValidUrl.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.18.18/node_modules/@visactor/vutils/es/common/isBase64.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.18.18/node_modules/@visactor/vutils/es/logger.js\");\n\n\n\n\nvar WORDCLOUD_SHAPE_HOOK_EVENT;\n\n!function(WORDCLOUD_SHAPE_HOOK_EVENT) {\n    WORDCLOUD_SHAPE_HOOK_EVENT.BEFORE_WORDCLOUD_SHAPE_LAYOUT = \"beforeWordcloudShapeLayout\", \n    WORDCLOUD_SHAPE_HOOK_EVENT.AFTER_WORDCLOUD_SHAPE_LAYOUT = \"afterWordcloudShapeLayout\", \n    WORDCLOUD_SHAPE_HOOK_EVENT.AFTER_WORDCLOUD_SHAPE_DRAW = \"afterWordcloudShapeDraw\";\n}(WORDCLOUD_SHAPE_HOOK_EVENT || (WORDCLOUD_SHAPE_HOOK_EVENT = {}));\n\nconst colorListEqual = (arr0, arr1) => {\n    if (1 === arr1.length && \"#537EF5\" === arr1[0]) return !0;\n    if (!Array.isArray(arr0) || !Array.isArray(arr1) || arr0.length !== arr1.length) return !1;\n    for (let i = 0; i < arr0.length; i++) if (arr0[i] !== arr1[i]) return !1;\n    return !0;\n};\n\nconst fakeRandom = () => {\n    let i = -1;\n    const arr = [ 0, .1, .2, .3, .4, .5, .6, .7, .8, .9 ];\n    return () => (i = (i + 1) % arr.length, arr[i]);\n};\n\nconst isChinese = text => /^[\\u4e00-\\u9fa5]+$/.test(text);\n\nconst calTextLength = (text, textLengthLimit) => {\n    if ((0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(text)) return 0;\n    let length = 0;\n    for (const char of text) isChinese(char) ? length += 1 : length += .53;\n    return length;\n};\n\nfunction loadImage(url) {\n    return url && ((0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(url) || (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(url) || url.startsWith(\"<svg\")) ? new Promise(((resolve, reject) => {\n        var _a;\n        const imageMark = (0,_visactor_vrender_core__WEBPACK_IMPORTED_MODULE_3__.createImage)({\n            image: url\n        }), imgData = null === (_a = imageMark.resources) || void 0 === _a ? void 0 : _a.get(url);\n        imgData && \"success\" === imgData.state && imgData.data ? resolve(imgData.data) : (imageMark.successCallback = () => {\n            var _a;\n            if (imageMark) {\n                const imgData = null === (_a = imageMark.resources) || void 0 === _a ? void 0 : _a.get(url);\n                imgData && \"success\" === imgData.state && imgData.data ? resolve(imgData.data) : reject(new Error(\"image load failed\" + url));\n            } else reject(new Error(\"image load failed\" + url));\n        }, imageMark.failCallback = () => {\n            _visactor_vutils__WEBPACK_IMPORTED_MODULE_4__.Logger.getInstance().error(\"image \", url);\n        });\n    })) : null;\n}\n\nfunction paintLabels(segmentationOutput) {\n    const {size: size, segmentation: {regions: regions, labels: labels}, shapeBounds: shapeBounds, shapeCenter: shapeCenter} = segmentationOutput, paintCanvas = _visactor_vrender_core__WEBPACK_IMPORTED_MODULE_5__.vglobal.createCanvas({\n        width: size[0],\n        height: size[1]\n    }), ctx = paintCanvas.getContext(\"2d\"), colorList = [ \"#FF0000\", \"#00FF00\", \"#0000FF\", \"#FFFF00\", \"#00FFFF\", \"#FF00FF\" ];\n    for (let i = 0; i < size[1]; i++) for (let j = 0; j < size[0]; j++) 0 === labels[i * size[0] + j] ? ctx.fillStyle = \"#fff\" : ctx.fillStyle = colorList[labels[i * size[0] + j] % colorList.length], \n    ctx.fillRect(j, i, 1, 1);\n    regions.forEach((region => {\n        const {center: [x, y], area: area, boundary: boundary, maxPoint: maxPoint, label: label} = region;\n        ctx.fillStyle = \"#000\", ctx.fillRect(x, y, 3, 3), ctx.font = \"15px serif\", ctx.fillText(area, x, y);\n        for (const [x, y] of boundary) ctx.fillStyle = \"#f00\", ctx.fillRect(x, y, 1, 1);\n        const [iMin, iMax, jMin, jMax] = maxPoint;\n        ctx.fillStyle = \"#00f\", ctx.font = \"15px serif\", ctx.fillRect(jMin, iMin, 3, 3), \n        ctx.fillText(`${label}_min`, jMin, iMin), ctx.fillRect(jMax, iMax, 3, 3), ctx.fillText(`${label}_max`, jMax, iMax);\n    }));\n    const {x1: x1, y1: y1, width: width, height: height} = shapeBounds;\n    ctx.strokeStyle = \"#000\", ctx.strokeRect(x1, y1, width, height), ctx.fillStyle = \"#000\", \n    ctx.fillRect(shapeCenter[0], shapeCenter[1], 3, 3), ctx.fillText(\"shape center\", shapeCenter[0], shapeCenter[1]), \n    document.body.prepend(paintCanvas);\n}\n\nfunction paint(board, paintSize) {\n    const curSize = paintSize, imageData = new ImageData(curSize[0], curSize[1]), array = imageData.data, w32 = paintSize[0] >> 5;\n    for (let y = 0; y < curSize[1]; y++) for (let x = 0; x < w32; x++) {\n        const string = (board[y * w32 + x] >>> 0).toString(2).padStart(32, \"0\");\n        for (let k = 0; k < 32; k++) \"1\" === string[k] ? (array[4 * ((x << 5) + y * curSize[0] + k) + 0] = 255, \n        array[4 * ((x << 5) + y * curSize[0] + k) + 1] = 255, array[4 * ((x << 5) + y * curSize[0] + k) + 2] = 255, \n        array[4 * ((x << 5) + y * curSize[0] + k) + 3] = 255) : (array[4 * ((x << 5) + y * curSize[0] + k) + 0] = 0, \n        array[4 * ((x << 5) + y * curSize[0] + k) + 1] = 0, array[4 * ((x << 5) + y * curSize[0] + k) + 2] = 0, \n        array[4 * ((x << 5) + y * curSize[0] + k) + 3] = 255), 0 === k && (array[4 * ((x << 5) + y * curSize[0] + k) + 0] = 255, \n        array[4 * ((x << 5) + y * curSize[0] + k) + 1] = 0, array[4 * ((x << 5) + y * curSize[0] + k) + 2] = 0, \n        array[4 * ((x << 5) + y * curSize[0] + k) + 3] = 255);\n    }\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = curSize[0], canvas.height = curSize[1];\n    canvas.getContext(\"2d\").putImageData(imageData, 0, 0), document.body.prepend(canvas);\n}\n\nfunction draw(words, fillingWords, layoutConfig, resizeFactor = 1) {\n    const canvas = document.createElement(\"canvas\"), {size: size} = (Math.PI, layoutConfig);\n    canvas.width = size[0] * resizeFactor, canvas.height = size[1] * resizeFactor;\n    const ctx = canvas.getContext(\"2d\");\n    function drawText(word, color) {\n        ctx.save(), ctx.textAlign = \"center\", ctx.font = word.fontStyle + \" \" + word.fontWeight + \" \" + word.fontSize * resizeFactor + \"px \" + word.fontFamily, \n        ctx.globalAlpha = word.opacity, ctx.translate(word.x * resizeFactor, word.y * resizeFactor), \n        word.rotate && ctx.rotate(word.rotate * Math.PI / 180), ctx.fillText(word.text, 0, .3 * word.fontSize * resizeFactor), \n        ctx.restore();\n    }\n    words.forEach((word => {\n        word.visible && drawText(word);\n    })), fillingWords.forEach((word => {\n        word.visible && drawText(word, \"#308ebc\");\n    })), document.body.prepend(canvas);\n}\n\nfunction drawSpiral(spiral, center, maxR, size) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = size[0], canvas.height = size[1];\n    const ctx = canvas.getContext(\"2d\");\n    let dxdy, dx, dy, t = -1;\n    for (;(dxdy = spiral(t += 1)) && (dx = dxdy[0], dy = dxdy[1], !(Math.min(Math.abs(dx), Math.abs(dy)) >= maxR)); ) ctx.fillStyle = \"#f00\", \n    ctx.fillRect(center[0] + dx, center[1] + dy, 3, 3);\n    document.body.prepend(canvas);\n}\n\nfunction functor(d) {\n    return \"function\" == typeof d ? d : function() {\n        return d;\n    };\n}\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZUAwLjE0LjEzL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItd29yZGNsb3VkLXNoYXBlL2VzL3V0aWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEQ7O0FBRVM7O0FBRWhFOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywrREFBK0Q7O0FBRXpEO0FBQ1A7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVBO0FBQ1AsUUFBUSw0REFBSztBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsbUJBQW1CLDREQUFVLFNBQVMsNERBQVE7QUFDOUM7QUFDQSwwQkFBMEIsbUVBQVc7QUFDckM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxTQUFTO0FBQ1QsWUFBWSxvREFBTTtBQUNsQixTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVPO0FBQ1AsV0FBVywyQkFBMkIsaUNBQWlDLHNEQUFzRCxvQ0FBb0MsMkRBQU87QUFDeEs7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0IsYUFBYSxxQkFBcUIsYUFBYTtBQUNuRTtBQUNBO0FBQ0EsZUFBZSxrRkFBa0Y7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBTSxvRUFBb0UsTUFBTTtBQUN4RyxLQUFLO0FBQ0wsV0FBVyw4Q0FBOEM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLG9CQUFvQixnQkFBZ0IscUJBQXFCLFNBQVM7QUFDbEU7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1Asc0RBQXNELFlBQVk7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMEdBQTBHO0FBQ3BIO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9meW5sYXRpY3MtYWkvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZUAwLjE0LjEzL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItd29yZGNsb3VkLXNoYXBlL2VzL3V0aWwuanM/MzI5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2Z2xvYmFsLCBjcmVhdGVJbWFnZSB9IGZyb20gXCJAdmlzYWN0b3IvdnJlbmRlci1jb3JlXCI7XG5cbmltcG9ydCB7IGlzQmFzZTY0LCBpc05pbCwgaXNWYWxpZFVybCwgTG9nZ2VyIH0gZnJvbSBcIkB2aXNhY3Rvci92dXRpbHNcIjtcblxuZXhwb3J0IHZhciBXT1JEQ0xPVURfU0hBUEVfSE9PS19FVkVOVDtcblxuIWZ1bmN0aW9uKFdPUkRDTE9VRF9TSEFQRV9IT09LX0VWRU5UKSB7XG4gICAgV09SRENMT1VEX1NIQVBFX0hPT0tfRVZFTlQuQkVGT1JFX1dPUkRDTE9VRF9TSEFQRV9MQVlPVVQgPSBcImJlZm9yZVdvcmRjbG91ZFNoYXBlTGF5b3V0XCIsIFxuICAgIFdPUkRDTE9VRF9TSEFQRV9IT09LX0VWRU5ULkFGVEVSX1dPUkRDTE9VRF9TSEFQRV9MQVlPVVQgPSBcImFmdGVyV29yZGNsb3VkU2hhcGVMYXlvdXRcIiwgXG4gICAgV09SRENMT1VEX1NIQVBFX0hPT0tfRVZFTlQuQUZURVJfV09SRENMT1VEX1NIQVBFX0RSQVcgPSBcImFmdGVyV29yZGNsb3VkU2hhcGVEcmF3XCI7XG59KFdPUkRDTE9VRF9TSEFQRV9IT09LX0VWRU5UIHx8IChXT1JEQ0xPVURfU0hBUEVfSE9PS19FVkVOVCA9IHt9KSk7XG5cbmV4cG9ydCBjb25zdCBjb2xvckxpc3RFcXVhbCA9IChhcnIwLCBhcnIxKSA9PiB7XG4gICAgaWYgKDEgPT09IGFycjEubGVuZ3RoICYmIFwiIzUzN0VGNVwiID09PSBhcnIxWzBdKSByZXR1cm4gITA7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycjApIHx8ICFBcnJheS5pc0FycmF5KGFycjEpIHx8IGFycjAubGVuZ3RoICE9PSBhcnIxLmxlbmd0aCkgcmV0dXJuICExO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyMC5sZW5ndGg7IGkrKykgaWYgKGFycjBbaV0gIT09IGFycjFbaV0pIHJldHVybiAhMTtcbiAgICByZXR1cm4gITA7XG59O1xuXG5leHBvcnQgY29uc3QgZmFrZVJhbmRvbSA9ICgpID0+IHtcbiAgICBsZXQgaSA9IC0xO1xuICAgIGNvbnN0IGFyciA9IFsgMCwgLjEsIC4yLCAuMywgLjQsIC41LCAuNiwgLjcsIC44LCAuOSBdO1xuICAgIHJldHVybiAoKSA9PiAoaSA9IChpICsgMSkgJSBhcnIubGVuZ3RoLCBhcnJbaV0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzQ2hpbmVzZSA9IHRleHQgPT4gL15bXFx1NGUwMC1cXHU5ZmE1XSskLy50ZXN0KHRleHQpO1xuXG5leHBvcnQgY29uc3QgY2FsVGV4dExlbmd0aCA9ICh0ZXh0LCB0ZXh0TGVuZ3RoTGltaXQpID0+IHtcbiAgICBpZiAoaXNOaWwodGV4dCkpIHJldHVybiAwO1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGZvciAoY29uc3QgY2hhciBvZiB0ZXh0KSBpc0NoaW5lc2UoY2hhcikgPyBsZW5ndGggKz0gMSA6IGxlbmd0aCArPSAuNTM7XG4gICAgcmV0dXJuIGxlbmd0aDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkSW1hZ2UodXJsKSB7XG4gICAgcmV0dXJuIHVybCAmJiAoaXNWYWxpZFVybCh1cmwpIHx8IGlzQmFzZTY0KHVybCkgfHwgdXJsLnN0YXJ0c1dpdGgoXCI8c3ZnXCIpKSA/IG5ldyBQcm9taXNlKCgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgaW1hZ2VNYXJrID0gY3JlYXRlSW1hZ2Uoe1xuICAgICAgICAgICAgaW1hZ2U6IHVybFxuICAgICAgICB9KSwgaW1nRGF0YSA9IG51bGwgPT09IChfYSA9IGltYWdlTWFyay5yZXNvdXJjZXMpIHx8IHZvaWQgMCA9PT0gX2EgPyB2b2lkIDAgOiBfYS5nZXQodXJsKTtcbiAgICAgICAgaW1nRGF0YSAmJiBcInN1Y2Nlc3NcIiA9PT0gaW1nRGF0YS5zdGF0ZSAmJiBpbWdEYXRhLmRhdGEgPyByZXNvbHZlKGltZ0RhdGEuZGF0YSkgOiAoaW1hZ2VNYXJrLnN1Y2Nlc3NDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChpbWFnZU1hcmspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbWdEYXRhID0gbnVsbCA9PT0gKF9hID0gaW1hZ2VNYXJrLnJlc291cmNlcykgfHwgdm9pZCAwID09PSBfYSA/IHZvaWQgMCA6IF9hLmdldCh1cmwpO1xuICAgICAgICAgICAgICAgIGltZ0RhdGEgJiYgXCJzdWNjZXNzXCIgPT09IGltZ0RhdGEuc3RhdGUgJiYgaW1nRGF0YS5kYXRhID8gcmVzb2x2ZShpbWdEYXRhLmRhdGEpIDogcmVqZWN0KG5ldyBFcnJvcihcImltYWdlIGxvYWQgZmFpbGVkXCIgKyB1cmwpKTtcbiAgICAgICAgICAgIH0gZWxzZSByZWplY3QobmV3IEVycm9yKFwiaW1hZ2UgbG9hZCBmYWlsZWRcIiArIHVybCkpO1xuICAgICAgICB9LCBpbWFnZU1hcmsuZmFpbENhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoXCJpbWFnZSDliqDovb3lpLHotKXvvIFcIiwgdXJsKTtcbiAgICAgICAgfSk7XG4gICAgfSkpIDogbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhaW50TGFiZWxzKHNlZ21lbnRhdGlvbk91dHB1dCkge1xuICAgIGNvbnN0IHtzaXplOiBzaXplLCBzZWdtZW50YXRpb246IHtyZWdpb25zOiByZWdpb25zLCBsYWJlbHM6IGxhYmVsc30sIHNoYXBlQm91bmRzOiBzaGFwZUJvdW5kcywgc2hhcGVDZW50ZXI6IHNoYXBlQ2VudGVyfSA9IHNlZ21lbnRhdGlvbk91dHB1dCwgcGFpbnRDYW52YXMgPSB2Z2xvYmFsLmNyZWF0ZUNhbnZhcyh7XG4gICAgICAgIHdpZHRoOiBzaXplWzBdLFxuICAgICAgICBoZWlnaHQ6IHNpemVbMV1cbiAgICB9KSwgY3R4ID0gcGFpbnRDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLCBjb2xvckxpc3QgPSBbIFwiI0ZGMDAwMFwiLCBcIiMwMEZGMDBcIiwgXCIjMDAwMEZGXCIsIFwiI0ZGRkYwMFwiLCBcIiMwMEZGRkZcIiwgXCIjRkYwMEZGXCIgXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemVbMV07IGkrKykgZm9yIChsZXQgaiA9IDA7IGogPCBzaXplWzBdOyBqKyspIDAgPT09IGxhYmVsc1tpICogc2l6ZVswXSArIGpdID8gY3R4LmZpbGxTdHlsZSA9IFwiI2ZmZlwiIDogY3R4LmZpbGxTdHlsZSA9IGNvbG9yTGlzdFtsYWJlbHNbaSAqIHNpemVbMF0gKyBqXSAlIGNvbG9yTGlzdC5sZW5ndGhdLCBcbiAgICBjdHguZmlsbFJlY3QoaiwgaSwgMSwgMSk7XG4gICAgcmVnaW9ucy5mb3JFYWNoKChyZWdpb24gPT4ge1xuICAgICAgICBjb25zdCB7Y2VudGVyOiBbeCwgeV0sIGFyZWE6IGFyZWEsIGJvdW5kYXJ5OiBib3VuZGFyeSwgbWF4UG9pbnQ6IG1heFBvaW50LCBsYWJlbDogbGFiZWx9ID0gcmVnaW9uO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjMDAwXCIsIGN0eC5maWxsUmVjdCh4LCB5LCAzLCAzKSwgY3R4LmZvbnQgPSBcIjE1cHggc2VyaWZcIiwgY3R4LmZpbGxUZXh0KGFyZWEsIHgsIHkpO1xuICAgICAgICBmb3IgKGNvbnN0IFt4LCB5XSBvZiBib3VuZGFyeSkgY3R4LmZpbGxTdHlsZSA9IFwiI2YwMFwiLCBjdHguZmlsbFJlY3QoeCwgeSwgMSwgMSk7XG4gICAgICAgIGNvbnN0IFtpTWluLCBpTWF4LCBqTWluLCBqTWF4XSA9IG1heFBvaW50O1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjMDBmXCIsIGN0eC5mb250ID0gXCIxNXB4IHNlcmlmXCIsIGN0eC5maWxsUmVjdChqTWluLCBpTWluLCAzLCAzKSwgXG4gICAgICAgIGN0eC5maWxsVGV4dChgJHtsYWJlbH1fbWluYCwgak1pbiwgaU1pbiksIGN0eC5maWxsUmVjdChqTWF4LCBpTWF4LCAzLCAzKSwgY3R4LmZpbGxUZXh0KGAke2xhYmVsfV9tYXhgLCBqTWF4LCBpTWF4KTtcbiAgICB9KSk7XG4gICAgY29uc3Qge3gxOiB4MSwgeTE6IHkxLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0fSA9IHNoYXBlQm91bmRzO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IFwiIzAwMFwiLCBjdHguc3Ryb2tlUmVjdCh4MSwgeTEsIHdpZHRoLCBoZWlnaHQpLCBjdHguZmlsbFN0eWxlID0gXCIjMDAwXCIsIFxuICAgIGN0eC5maWxsUmVjdChzaGFwZUNlbnRlclswXSwgc2hhcGVDZW50ZXJbMV0sIDMsIDMpLCBjdHguZmlsbFRleHQoXCJzaGFwZSBjZW50ZXJcIiwgc2hhcGVDZW50ZXJbMF0sIHNoYXBlQ2VudGVyWzFdKSwgXG4gICAgZG9jdW1lbnQuYm9keS5wcmVwZW5kKHBhaW50Q2FudmFzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhaW50KGJvYXJkLCBwYWludFNpemUpIHtcbiAgICBjb25zdCBjdXJTaXplID0gcGFpbnRTaXplLCBpbWFnZURhdGEgPSBuZXcgSW1hZ2VEYXRhKGN1clNpemVbMF0sIGN1clNpemVbMV0pLCBhcnJheSA9IGltYWdlRGF0YS5kYXRhLCB3MzIgPSBwYWludFNpemVbMF0gPj4gNTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGN1clNpemVbMV07IHkrKykgZm9yIChsZXQgeCA9IDA7IHggPCB3MzI7IHgrKykge1xuICAgICAgICBjb25zdCBzdHJpbmcgPSAoYm9hcmRbeSAqIHczMiArIHhdID4+PiAwKS50b1N0cmluZygyKS5wYWRTdGFydCgzMiwgXCIwXCIpO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IDMyOyBrKyspIFwiMVwiID09PSBzdHJpbmdba10gPyAoYXJyYXlbNCAqICgoeCA8PCA1KSArIHkgKiBjdXJTaXplWzBdICsgaykgKyAwXSA9IDI1NSwgXG4gICAgICAgIGFycmF5WzQgKiAoKHggPDwgNSkgKyB5ICogY3VyU2l6ZVswXSArIGspICsgMV0gPSAyNTUsIGFycmF5WzQgKiAoKHggPDwgNSkgKyB5ICogY3VyU2l6ZVswXSArIGspICsgMl0gPSAyNTUsIFxuICAgICAgICBhcnJheVs0ICogKCh4IDw8IDUpICsgeSAqIGN1clNpemVbMF0gKyBrKSArIDNdID0gMjU1KSA6IChhcnJheVs0ICogKCh4IDw8IDUpICsgeSAqIGN1clNpemVbMF0gKyBrKSArIDBdID0gMCwgXG4gICAgICAgIGFycmF5WzQgKiAoKHggPDwgNSkgKyB5ICogY3VyU2l6ZVswXSArIGspICsgMV0gPSAwLCBhcnJheVs0ICogKCh4IDw8IDUpICsgeSAqIGN1clNpemVbMF0gKyBrKSArIDJdID0gMCwgXG4gICAgICAgIGFycmF5WzQgKiAoKHggPDwgNSkgKyB5ICogY3VyU2l6ZVswXSArIGspICsgM10gPSAyNTUpLCAwID09PSBrICYmIChhcnJheVs0ICogKCh4IDw8IDUpICsgeSAqIGN1clNpemVbMF0gKyBrKSArIDBdID0gMjU1LCBcbiAgICAgICAgYXJyYXlbNCAqICgoeCA8PCA1KSArIHkgKiBjdXJTaXplWzBdICsgaykgKyAxXSA9IDAsIGFycmF5WzQgKiAoKHggPDwgNSkgKyB5ICogY3VyU2l6ZVswXSArIGspICsgMl0gPSAwLCBcbiAgICAgICAgYXJyYXlbNCAqICgoeCA8PCA1KSArIHkgKiBjdXJTaXplWzBdICsgaykgKyAzXSA9IDI1NSk7XG4gICAgfVxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gY3VyU2l6ZVswXSwgY2FudmFzLmhlaWdodCA9IGN1clNpemVbMV07XG4gICAgY2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKSwgZG9jdW1lbnQuYm9keS5wcmVwZW5kKGNhbnZhcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkcmF3KHdvcmRzLCBmaWxsaW5nV29yZHMsIGxheW91dENvbmZpZywgcmVzaXplRmFjdG9yID0gMSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksIHtzaXplOiBzaXplfSA9IChNYXRoLlBJLCBsYXlvdXRDb25maWcpO1xuICAgIGNhbnZhcy53aWR0aCA9IHNpemVbMF0gKiByZXNpemVGYWN0b3IsIGNhbnZhcy5oZWlnaHQgPSBzaXplWzFdICogcmVzaXplRmFjdG9yO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgZnVuY3Rpb24gZHJhd1RleHQod29yZCwgY29sb3IpIHtcbiAgICAgICAgY3R4LnNhdmUoKSwgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCIsIGN0eC5mb250ID0gd29yZC5mb250U3R5bGUgKyBcIiBcIiArIHdvcmQuZm9udFdlaWdodCArIFwiIFwiICsgd29yZC5mb250U2l6ZSAqIHJlc2l6ZUZhY3RvciArIFwicHggXCIgKyB3b3JkLmZvbnRGYW1pbHksIFxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSB3b3JkLm9wYWNpdHksIGN0eC50cmFuc2xhdGUod29yZC54ICogcmVzaXplRmFjdG9yLCB3b3JkLnkgKiByZXNpemVGYWN0b3IpLCBcbiAgICAgICAgd29yZC5yb3RhdGUgJiYgY3R4LnJvdGF0ZSh3b3JkLnJvdGF0ZSAqIE1hdGguUEkgLyAxODApLCBjdHguZmlsbFRleHQod29yZC50ZXh0LCAwLCAuMyAqIHdvcmQuZm9udFNpemUgKiByZXNpemVGYWN0b3IpLCBcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgd29yZHMuZm9yRWFjaCgod29yZCA9PiB7XG4gICAgICAgIHdvcmQudmlzaWJsZSAmJiBkcmF3VGV4dCh3b3JkKTtcbiAgICB9KSksIGZpbGxpbmdXb3Jkcy5mb3JFYWNoKCh3b3JkID0+IHtcbiAgICAgICAgd29yZC52aXNpYmxlICYmIGRyYXdUZXh0KHdvcmQsIFwiIzMwOGViY1wiKTtcbiAgICB9KSksIGRvY3VtZW50LmJvZHkucHJlcGVuZChjYW52YXMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZHJhd1NwaXJhbChzcGlyYWwsIGNlbnRlciwgbWF4Uiwgc2l6ZSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gc2l6ZVswXSwgY2FudmFzLmhlaWdodCA9IHNpemVbMV07XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBsZXQgZHhkeSwgZHgsIGR5LCB0ID0gLTE7XG4gICAgZm9yICg7KGR4ZHkgPSBzcGlyYWwodCArPSAxKSkgJiYgKGR4ID0gZHhkeVswXSwgZHkgPSBkeGR5WzFdLCAhKE1hdGgubWluKE1hdGguYWJzKGR4KSwgTWF0aC5hYnMoZHkpKSA+PSBtYXhSKSk7ICkgY3R4LmZpbGxTdHlsZSA9IFwiI2YwMFwiLCBcbiAgICBjdHguZmlsbFJlY3QoY2VudGVyWzBdICsgZHgsIGNlbnRlclsxXSArIGR5LCAzLCAzKTtcbiAgICBkb2N1bWVudC5ib2R5LnByZXBlbmQoY2FudmFzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZ1bmN0b3IoZCkge1xuICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGQgPyBkIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBkO1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/wordcloud-shape.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/wordcloud-shape.js ***!
  \*********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   transform: () => (/* binding */ transform)\n/* harmony export */ });\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.18.18/node_modules/@visactor/vutils/es/common/isNil.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.18.18/node_modules/@visactor/vutils/es/logger.js\");\n/* harmony import */ var _visactor_vgrammar_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @visactor/vgrammar-util */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-util@0.14.13/node_modules/@visactor/vgrammar-util/es/error.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/util.js\");\n/* harmony import */ var _layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./layout */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/layout.js\");\n\n\n\n\n\n\n\n\nconst transform = (options, upstreamData, parameters, view) => {\n    if (!options.size || (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(options.size[0]) || (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(options.size[1]) || options.size[0] <= 0 || options.size[1] <= 0) {\n        return _visactor_vutils__WEBPACK_IMPORTED_MODULE_1__.Logger.getInstance().info(\"Wordcloud size dimensions must be greater than 0\"), \n        [];\n    }\n    if (options.size = [ Math.ceil(options.size[0]), Math.ceil(options.size[1]) ], options.shape || (0,_visactor_vgrammar_util__WEBPACK_IMPORTED_MODULE_2__.error)(\"WordcloudShape shape must be specified.\"), \n    options.text || (0,_visactor_vgrammar_util__WEBPACK_IMPORTED_MODULE_2__.error)(\"WordcloudShape text must be specified.\"), (null == view ? void 0 : view.emit) && view.emit(_util__WEBPACK_IMPORTED_MODULE_3__.WORDCLOUD_SHAPE_HOOK_EVENT.BEFORE_WORDCLOUD_SHAPE_LAYOUT), \n    !upstreamData || 0 === upstreamData.length) return [];\n    const layout = new _layout__WEBPACK_IMPORTED_MODULE_4__.Layout(options, view);\n    return layout.layout(upstreamData), layout.unfinished() ? {\n        progressive: layout\n    } : layout.output();\n};\n//# sourceMappingURL=wordcloud-shape.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZUAwLjE0LjEzL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItd29yZGNsb3VkLXNoYXBlL2VzL3dvcmRjbG91ZC1zaGFwZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBaUQ7O0FBRUQ7O0FBRUk7O0FBRWxCOztBQUUzQjtBQUNQLHlCQUF5Qiw0REFBSyxxQkFBcUIsNERBQUs7QUFDeEQsZUFBZSxvREFBTTtBQUNyQjtBQUNBO0FBQ0Esb0dBQW9HLDhEQUFLO0FBQ3pHLG9CQUFvQiw4REFBSyw2RkFBNkYsNkRBQTBCO0FBQ2hKO0FBQ0EsdUJBQXVCLDJDQUFNO0FBQzdCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Z5bmxhdGljcy1haS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdmlzYWN0b3IrdmdyYW1tYXItd29yZGNsb3VkLXNoYXBlQDAuMTQuMTMvbm9kZV9tb2R1bGVzL0B2aXNhY3Rvci92Z3JhbW1hci13b3JkY2xvdWQtc2hhcGUvZXMvd29yZGNsb3VkLXNoYXBlLmpzPzhhNGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTG9nZ2VyLCBpc05pbCB9IGZyb20gXCJAdmlzYWN0b3IvdnV0aWxzXCI7XG5cbmltcG9ydCB7IGVycm9yIH0gZnJvbSBcIkB2aXNhY3Rvci92Z3JhbW1hci11dGlsXCI7XG5cbmltcG9ydCB7IFdPUkRDTE9VRF9TSEFQRV9IT09LX0VWRU5UIH0gZnJvbSBcIi4vdXRpbFwiO1xuXG5pbXBvcnQgeyBMYXlvdXQgfSBmcm9tIFwiLi9sYXlvdXRcIjtcblxuZXhwb3J0IGNvbnN0IHRyYW5zZm9ybSA9IChvcHRpb25zLCB1cHN0cmVhbURhdGEsIHBhcmFtZXRlcnMsIHZpZXcpID0+IHtcbiAgICBpZiAoIW9wdGlvbnMuc2l6ZSB8fCBpc05pbChvcHRpb25zLnNpemVbMF0pIHx8IGlzTmlsKG9wdGlvbnMuc2l6ZVsxXSkgfHwgb3B0aW9ucy5zaXplWzBdIDw9IDAgfHwgb3B0aW9ucy5zaXplWzFdIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oXCJXb3JkY2xvdWQgc2l6ZSBkaW1lbnNpb25zIG11c3QgYmUgZ3JlYXRlciB0aGFuIDBcIiksIFxuICAgICAgICBbXTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc2l6ZSA9IFsgTWF0aC5jZWlsKG9wdGlvbnMuc2l6ZVswXSksIE1hdGguY2VpbChvcHRpb25zLnNpemVbMV0pIF0sIG9wdGlvbnMuc2hhcGUgfHwgZXJyb3IoXCJXb3JkY2xvdWRTaGFwZSBzaGFwZSBtdXN0IGJlIHNwZWNpZmllZC5cIiksIFxuICAgIG9wdGlvbnMudGV4dCB8fCBlcnJvcihcIldvcmRjbG91ZFNoYXBlIHRleHQgbXVzdCBiZSBzcGVjaWZpZWQuXCIpLCAobnVsbCA9PSB2aWV3ID8gdm9pZCAwIDogdmlldy5lbWl0KSAmJiB2aWV3LmVtaXQoV09SRENMT1VEX1NIQVBFX0hPT0tfRVZFTlQuQkVGT1JFX1dPUkRDTE9VRF9TSEFQRV9MQVlPVVQpLCBcbiAgICAhdXBzdHJlYW1EYXRhIHx8IDAgPT09IHVwc3RyZWFtRGF0YS5sZW5ndGgpIHJldHVybiBbXTtcbiAgICBjb25zdCBsYXlvdXQgPSBuZXcgTGF5b3V0KG9wdGlvbnMsIHZpZXcpO1xuICAgIHJldHVybiBsYXlvdXQubGF5b3V0KHVwc3RyZWFtRGF0YSksIGxheW91dC51bmZpbmlzaGVkKCkgPyB7XG4gICAgICAgIHByb2dyZXNzaXZlOiBsYXlvdXRcbiAgICB9IDogbGF5b3V0Lm91dHB1dCgpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmRjbG91ZC1zaGFwZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/wordcloud-shape.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/wordle.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/wordle.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isCollideWithBoard: () => (/* binding */ isCollideWithBoard),\n/* harmony export */   layout: () => (/* binding */ layout),\n/* harmony export */   layoutGlobalShrink: () => (/* binding */ layoutGlobalShrink),\n/* harmony export */   layoutSelfEnlarge: () => (/* binding */ layoutSelfEnlarge),\n/* harmony export */   layoutSelfShrink: () => (/* binding */ layoutSelfShrink),\n/* harmony export */   measureSprite: () => (/* binding */ measureSprite),\n/* harmony export */   placeWordOnBoard: () => (/* binding */ placeWordOnBoard)\n/* harmony export */ });\nfunction layout(words, layoutConfig, segmentationOutput) {\n    const {size: size, stepFactor: stepFactor} = layoutConfig, {segmentation: {regions: regions}, tempCanvas: canvas, boardSize: boardSize, shapeCenter: shapeCenter, shapeMaxR: shapeMaxR, shapeRatio: shapeRatio} = segmentationOutput, board = initBoardWithShape(segmentationOutput), ctx = canvas.getContext(\"2d\", {\n        willReadFrequently: !0\n    });\n    for (const region of regions) {\n        const {words: regionWords, center: center, maxR: maxR, ratio: ratio} = region;\n        for (let i = 0; i < regionWords.length; i++) {\n            measureSprite(canvas, ctx, words, i);\n            const word = regionWords[i];\n            word.x = center[0], word.y = center[1], word.hasText && word.sprite && place(board, word, maxR, ratio, size, boardSize, stepFactor) && (word.hasPlaced = !0);\n        }\n    }\n    for (let _ = 0; _ < layoutConfig.textLayoutTimes; _++) {\n        const failedWords = words.filter((word => (word.hasPlaced || (word.hasText = !1, \n        word.sprite = null, word.fontSize = Math.max(~~(word.fontSize * layoutConfig.fontSizeShrinkFactor), layoutConfig.minFontSize)), \n        !word.hasPlaced)));\n        if (0 === failedWords.length) break;\n        for (let i = 0; i < failedWords.length; i++) {\n            const word = failedWords[i];\n            measureSprite(canvas, ctx, failedWords, i), word.x = shapeCenter[0], word.y = shapeCenter[1], \n            word.hasText && place(board, word, shapeMaxR, shapeRatio, size, boardSize, stepFactor) && (word.hasPlaced = !0);\n        }\n    }\n    layoutConfig.board = board;\n}\n\nfunction layoutSelfShrink(words, layoutConfig, segmentationOutput) {\n    const {size: size, stepFactor: stepFactor} = layoutConfig, {segmentation: {regions: regions}, tempCanvas: canvas, boardSize: boardSize} = segmentationOutput, board = initBoardWithShape(segmentationOutput), ctx = canvas.getContext(\"2d\", {\n        willReadFrequently: !0\n    });\n    for (const region of regions) {\n        const {words: regionWords, center: center, maxR: maxR, ratio: ratio} = region;\n        let fontFactor = 1;\n        for (let i = 0; i < regionWords.length; i++) {\n            measureSprite(canvas, ctx, words, i);\n            const word = regionWords[i];\n            if (word.x = center[0], word.y = center[1], word.hasText && word.sprite && place(board, word, maxR, ratio, size, boardSize, stepFactor)) word.hasPlaced = !0; else {\n                fontFactor *= layoutConfig.fontSizeShrinkFactor;\n                for (let j = i; j < regionWords.length; j++) word.hasText = !1, word.sprite = null, \n                word.fontSize = Math.max(~~(word.fontSize * fontFactor), layoutConfig.minFontSize);\n                i--;\n            }\n        }\n    }\n    layoutConfig.board = board;\n}\n\nfunction layoutGlobalShrink(words, layoutConfig, segmentationOutput) {\n    const {stepFactor: stepFactor, importantWordCount: importantWordCount, globalShinkLimit: globalShinkLimit} = layoutConfig, {size: size, segmentation: {regions: regions}, tempCanvas: canvas, boardSize: boardSize, shapeCenter: shapeCenter, shapeMaxR: shapeMaxR, shapeRatio: shapeRatio} = segmentationOutput, ctx = canvas.getContext(\"2d\", {\n        willReadFrequently: !0\n    }), boardOrigin = initBoardWithShape(segmentationOutput);\n    let board = boardOrigin.slice(0);\n    const fontFactor = layoutConfig.fontSizeShrinkFactor;\n    let id = null, idIntialFactor = 1, globalShinkFactor = 1;\n    const importantCount = importantWordCount;\n    let weightStd = 0;\n    if (words.length > importantCount) {\n        weightStd = words.sort(((word0, word1) => word1.weight - word0.weight))[importantCount].weight;\n    }\n    for (let k = 0; k < regions.length; k++) {\n        const region = regions[k], {words: regionWords, center: center, maxR: maxR, ratio: ratio} = region;\n        let restartTag = !1;\n        for (let i = 0; i < regionWords.length; i++) {\n            measureSprite(canvas, ctx, words, i);\n            const word = regionWords[i];\n            if (word.x = center[0], word.y = center[1], !word.skip && word.hasText && word.sprite && place(board, word, maxR, ratio, size, boardSize, stepFactor)) word.hasPlaced = !0; else {\n                if (!word.skip && word.weight > weightStd && globalShinkFactor > globalShinkLimit) {\n                    const wordId = word.datum[Symbol.for(\"vGrammar_id\")];\n                    wordId !== id && (id = wordId, idIntialFactor = globalShinkFactor), globalShinkFactor *= fontFactor, \n                    words.forEach((word => {\n                        word.hasText = !1, word.sprite = null, word.fontSize = word.fontSize * fontFactor;\n                    })), board = boardOrigin.slice(0), restartTag = !0;\n                    break;\n                }\n                if (!word.skip && word.datum[Symbol.for(\"vGrammar_id\")] === id) {\n                    words.forEach((word => {\n                        word.hasText = !1, word.sprite = null, word.fontSize = word.fontSize / globalShinkFactor;\n                    })), word.skip = !0, globalShinkFactor = idIntialFactor, id = null, board = boardOrigin.slice(0), \n                    restartTag = !0;\n                    break;\n                }\n            }\n        }\n        restartTag && (k = -1);\n    }\n    for (let _ = 0; _ < layoutConfig.textLayoutTimes; _++) {\n        const failedWords = words.filter((word => (word.hasPlaced || (word.hasText = !1, \n        word.sprite = null, word.fontSize = Math.max(~~(word.fontSize * layoutConfig.fontSizeShrinkFactor), layoutConfig.minFontSize)), \n        !word.hasPlaced)));\n        if (0 === failedWords.length) break;\n        for (let i = 0; i < failedWords.length; i++) {\n            const word = failedWords[i];\n            measureSprite(canvas, ctx, failedWords, i), word.x = shapeCenter[0], word.y = shapeCenter[1], \n            word.hasText && place(board, word, shapeMaxR, shapeRatio, size, boardSize, stepFactor) && (word.hasPlaced = !0);\n        }\n    }\n    layoutConfig.board = board;\n}\n\nfunction layoutSelfEnlarge(words, layoutConfig, segmentationOutput) {\n    const {size: size, stepFactor: stepFactor, importantWordCount: importantWordCount} = layoutConfig, {segmentation: {regions: regions}, tempCanvas: canvas, boardSize: boardSize, shapeCenter: shapeCenter, shapeMaxR: shapeMaxR, shapeRatio: shapeRatio} = segmentationOutput, ctx = canvas.getContext(\"2d\", {\n        willReadFrequently: !0\n    }), boardOrigin = initBoardWithShape(segmentationOutput);\n    let board = boardOrigin.slice(0);\n    const fontFactor = layoutConfig.fontSizeEnlargeFactor, importantCount = Math.min(importantWordCount, words.length);\n    let weightStd = 0;\n    if (words.length > importantCount) {\n        weightStd = words.sort(((word0, word1) => word1.weight - word0.weight))[importantCount - 1].weight;\n    }\n    let importantWordSuccessedNum = 0, globalEnlargeFactor = 1, layoutFinish = !1;\n    for (let k = 0; k < regions.length; k++) {\n        const region = regions[k], {words: regionWords, center: center, maxR: maxR, ratio: ratio} = region;\n        let restartTag = !1;\n        for (let i = 0; i < regionWords.length; i++) {\n            measureSprite(canvas, ctx, words, i);\n            const word = regionWords[i];\n            if (word.x = center[0], word.y = center[1], word.hasText && word.sprite && place(board, word, maxR, ratio, size, boardSize, stepFactor)) {\n                if (word.hasPlaced = !0, word.weight >= weightStd && importantWordSuccessedNum++, \n                importantWordSuccessedNum >= importantCount && !layoutFinish) {\n                    globalEnlargeFactor *= fontFactor, words.forEach((word => {\n                        word.hasText = !1, word.sprite = null, word.fontSize = word.fontSize * fontFactor;\n                    })), board = boardOrigin.slice(0), restartTag = !0, importantWordSuccessedNum = 0;\n                    break;\n                }\n            } else {\n                if (word.weight >= weightStd && globalEnlargeFactor > 1) {\n                    words.forEach((word => {\n                        word.hasText = !1, word.sprite = null, word.fontSize = word.fontSize / fontFactor;\n                    })), globalEnlargeFactor /= fontFactor, layoutFinish = !0, board = boardOrigin.slice(0), \n                    restartTag = !0;\n                    break;\n                }\n                if (word.weight >= weightStd) return layoutGlobalShrink(words, layoutConfig, segmentationOutput);\n            }\n        }\n        restartTag && (k = -1);\n    }\n    for (let _ = 0; _ < layoutConfig.textLayoutTimes; _++) {\n        const failedWords = words.filter((word => (word.hasPlaced || (word.hasText = !1, \n        word.sprite = null, word.fontSize = Math.max(~~(word.fontSize * layoutConfig.fontSizeShrinkFactor), layoutConfig.minFontSize)), \n        !word.hasPlaced)));\n        if (0 === failedWords.length) break;\n        for (let i = 0; i < failedWords.length; i++) {\n            const word = failedWords[i];\n            measureSprite(canvas, ctx, failedWords, i), word.x = shapeCenter[0], word.y = shapeCenter[1], \n            word.hasText && place(board, word, shapeMaxR, shapeRatio, size, boardSize, stepFactor) && (word.hasPlaced = !0);\n        }\n    }\n    layoutConfig.board = board;\n}\n\nfunction place(board, word, maxR, ratio, size, boardSize, stepFactor) {\n    const startX = word.x, startY = word.y, spiral = archimedeanSpiral(ratio), dt = 1 * stepFactor;\n    let dxdy, dx, dy, t = -dt;\n    for (;dxdy = spiral(t += dt); ) {\n        const {wordSize: wordSize, bounds: {dTop: dTop, dBottom: dBottom, dLeft: dLeft, dRight: dRight}} = word;\n        if (dx = dxdy[0], dy = dxdy[1], Math.min(Math.abs(dx), Math.abs(dy)) >= maxR) break;\n        if (word.x = ~~(startX + dx), word.y = ~~(startY + dy), !(word.x - dLeft < 0 || word.x + dRight > size[0] || word.y - dTop < 0 || word.y + dBottom > size[1] || isCollideWithBoard(word, board, boardSize))) return placeWordOnBoard(word, board, boardSize), \n        !0;\n    }\n    return !1;\n}\n\nfunction placeWordOnBoard(word, board, boardSize) {\n    const {wordSize: wordSize} = word, sprite = word.sprite, w = wordSize[0] >> 5, sw = boardSize[0] >> 5, lx = word.x - (w << 4), sx = lx % 32, msx = 32 - sx, h = wordSize[1];\n    let last, x = (word.y - (wordSize[1] >> 1)) * sw + (lx >> 5);\n    if (0 === sx) for (let j = 0; j < h; j++) {\n        for (let i = 0; i < w; i++) board[x + i] |= sprite[j * w + i];\n        x += sw;\n    } else for (let j = 0; j < h; j++) {\n        last = 0;\n        for (let i = 0; i <= w; i++) board[x + i] |= last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);\n        x += sw;\n    }\n}\n\nfunction isCollideWithBoard(word, board, boardSize) {\n    const {sprite: sprite, wordSize: wordSize} = word, sw = boardSize[0] >> 5, w = wordSize[0] >> 5, lx = word.x - (w << 4), sx = lx % 32, msx = 32 - sx, h = wordSize[1];\n    let last, x = (word.y - (wordSize[1] >> 1)) * sw + (lx >> 5);\n    if (0 === sx) for (let j = 0; j < h; j++) {\n        for (let i = 0; i < w; i++) if (board[x + i] & sprite[j * w + i]) return !0;\n        x += sw;\n    } else for (let j = 0; j < h; j++) {\n        last = 0;\n        for (let i = 0; i <= w; i++) if ((last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) & board[x + i]) return !0;\n        x += sw;\n    }\n    return !1;\n}\n\nfunction archimedeanSpiral(ratio) {\n    return function(t) {\n        return [ ratio * (t *= .1) * Math.cos(t), t * Math.sin(t) ];\n    };\n}\n\nfunction measureSprite(canvas, ctx, words, wi) {\n    if (words[wi].sprite || 0 === words[wi].fontSize) return;\n    const cw = 2048, radians = Math.PI / 180, n = words.length;\n    canvas.width = cw, canvas.height = 2048, ctx.clearRect(0, 0, cw, 2048), ctx.textAlign = \"center\";\n    let wordW, wordH, x = 0, y = 0, maxHeight = 0, yMax = 0;\n    const wiDist = wi;\n    for (--wi; ++wi < n; ) {\n        const word = words[wi], fontSize = Math.max(word.fontSize, 2);\n        if (ctx.save(), ctx.font = word.fontStyle + \" \" + word.fontWeight + \" \" + fontSize + \"px \" + word.fontFamily, \n        wordW = ctx.measureText(word.text + \"m\").width + 2 * word.padding, wordH = 2 * fontSize + 2 * word.padding, \n        0 !== word.rotate) {\n            const sr = Math.sin(word.rotate * radians), cr = Math.cos(word.rotate * radians), wcr = wordW * cr, wsr = wordW * sr, hcr = wordH * cr, hsr = wordH * sr;\n            wordW = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)), wordH = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));\n        }\n        if (wordW = wordW + 31 >> 5 << 5, wordH = Math.ceil(wordH), wordH > maxHeight && (maxHeight = wordH), \n        x + wordW >= cw && (x = 0, y += maxHeight, maxHeight = wordH), y + wordH >= 2048) {\n            if (0 === y) {\n                word.hasText = !1;\n                continue;\n            }\n            break;\n        }\n        y + wordH >= yMax && (yMax = y + wordH), ctx.translate(x + (wordW >> 1), y + (wordH >> 1)), \n        0 !== word.rotate && ctx.rotate(word.rotate * radians), ctx.fillText(word.text, 0, 0), \n        word.padding && (ctx.lineWidth = 2 * word.padding, ctx.strokeText(word.text, 0, 0)), \n        ctx.restore(), word.LT = [ x, y ], word.wordSize = [ wordW, wordH ], word.hasText = !0, \n        x += wordW;\n    }\n    if (0 === yMax) return;\n    const pixels = ctx.getImageData(0, 0, cw, yMax).data;\n    let i, j;\n    for (;--wi >= wiDist; ) {\n        const word = words[wi];\n        if (!word.hasText) {\n            word.bounds = {\n                dTop: 1 / 0,\n                dBottom: -1 / 0,\n                dLeft: 1 / 0,\n                dRight: -1 / 0\n            };\n            break;\n        }\n        const {LT: LT = [ 0, 0 ], wordSize: wordSize} = word;\n        [x, y] = LT;\n        const w32 = wordSize[0] >> 5, sprite = new Array(w32 * wordSize[1]).fill(0);\n        let [dTop, dBottom, dLeft, dRight] = [ 1 / 0, -1 / 0, 1 / 0, -1 / 0 ];\n        for (j = 0; j < wordSize[1]; j++) {\n            let seen;\n            for (i = 0; i < wordSize[0]; i++) if (pixels[4 * ((y + j) * cw + (x + i)) + 3] > 0) {\n                const m = 1 << 31 - i % 32;\n                sprite[w32 * j + (i >> 5)] |= m, i < dLeft && (dLeft = i), i > dRight && (dRight = i), \n                seen |= m;\n            }\n            seen && (j < dTop && (dTop = j), j > dBottom && (dBottom = j));\n        }\n        word.bounds = {\n            dTop: (wordSize[1] >> 1) - dTop,\n            dBottom: dBottom - (wordSize[1] >> 1),\n            dLeft: (wordSize[0] >> 1) - dLeft,\n            dRight: dRight - (wordSize[0] >> 1)\n        }, word.sprite = sprite, delete word.LT;\n    }\n}\n\nfunction initBoardWithShape(segmentationOutput) {\n    const {segmentation: {labels: labels}, boardSize: boardSize, size: size} = segmentationOutput, w32 = boardSize[0] >> 5, board = new Array(w32 * size[1]).fill(0);\n    for (let i = 0; i < size[1]; i++) for (let j = 0; j < size[0]; j++) {\n        if (0 === labels[i * size[0] + j]) {\n            const m = 1 << 31 - j % 32;\n            board[w32 * i + (j >> 5)] |= m;\n        }\n    }\n    if (boardSize[0] > size[0]) {\n        const m = (1 << boardSize[0] - size[0]) - 1;\n        for (let y = 0; y < size[1]; y++) {\n            board[w32 * y + w32 - 1] |= m;\n        }\n    }\n    return board;\n}\n//# sourceMappingURL=wordle.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZUAwLjE0LjEzL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItd29yZGNsb3VkLXNoYXBlL2VzL3dvcmRsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQU87QUFDUCxXQUFXLG9DQUFvQyxpQkFBaUIsZUFBZSxpQkFBaUIsb0hBQW9IO0FBQ3BOO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZUFBZSw4REFBOEQ7QUFDN0Usd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFrQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxXQUFXLG9DQUFvQyxpQkFBaUIsZUFBZSxpQkFBaUIsNENBQTRDO0FBQzVJO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZUFBZSw4REFBOEQ7QUFDN0U7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQSwwS0FBMEs7QUFDMUs7QUFDQSxnQ0FBZ0Msd0JBQXdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsV0FBVyxvR0FBb0csaUJBQWlCLDJCQUEyQixpQkFBaUIsb0hBQW9IO0FBQ2hTO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDLG9DQUFvQyw4REFBOEQ7QUFDbEc7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQSx3TEFBd0w7QUFDeEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFrQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxXQUFXLDRFQUE0RSxpQkFBaUIsZUFBZSxpQkFBaUIsb0hBQW9IO0FBQzVQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QyxvQ0FBb0MsOERBQThEO0FBQ2xHO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFrQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEMsZUFBZSw2QkFBNkIsNkRBQTZEO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0Esa0NBQWtDLE9BQU87QUFDekMsd0JBQXdCLE9BQU87QUFDL0I7QUFDQSxNQUFNLHFCQUFxQixPQUFPO0FBQ2xDO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBOztBQUVPO0FBQ1AsV0FBVyxvQ0FBb0M7QUFDL0M7QUFDQSxrQ0FBa0MsT0FBTztBQUN6Qyx3QkFBd0IsT0FBTztBQUMvQjtBQUNBLE1BQU0scUJBQXFCLE9BQU87QUFDbEM7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUNBQXVDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLFdBQVcsZUFBZSxlQUFlLG9DQUFvQztBQUM3RSxvQkFBb0IsYUFBYSxxQkFBcUIsYUFBYTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Z5bmxhdGljcy1haS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdmlzYWN0b3IrdmdyYW1tYXItd29yZGNsb3VkLXNoYXBlQDAuMTQuMTMvbm9kZV9tb2R1bGVzL0B2aXNhY3Rvci92Z3JhbW1hci13b3JkY2xvdWQtc2hhcGUvZXMvd29yZGxlLmpzP2RhNjUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGxheW91dCh3b3JkcywgbGF5b3V0Q29uZmlnLCBzZWdtZW50YXRpb25PdXRwdXQpIHtcbiAgICBjb25zdCB7c2l6ZTogc2l6ZSwgc3RlcEZhY3Rvcjogc3RlcEZhY3Rvcn0gPSBsYXlvdXRDb25maWcsIHtzZWdtZW50YXRpb246IHtyZWdpb25zOiByZWdpb25zfSwgdGVtcENhbnZhczogY2FudmFzLCBib2FyZFNpemU6IGJvYXJkU2l6ZSwgc2hhcGVDZW50ZXI6IHNoYXBlQ2VudGVyLCBzaGFwZU1heFI6IHNoYXBlTWF4Uiwgc2hhcGVSYXRpbzogc2hhcGVSYXRpb30gPSBzZWdtZW50YXRpb25PdXRwdXQsIGJvYXJkID0gaW5pdEJvYXJkV2l0aFNoYXBlKHNlZ21lbnRhdGlvbk91dHB1dCksIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6ICEwXG4gICAgfSk7XG4gICAgZm9yIChjb25zdCByZWdpb24gb2YgcmVnaW9ucykge1xuICAgICAgICBjb25zdCB7d29yZHM6IHJlZ2lvbldvcmRzLCBjZW50ZXI6IGNlbnRlciwgbWF4UjogbWF4UiwgcmF0aW86IHJhdGlvfSA9IHJlZ2lvbjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWdpb25Xb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbWVhc3VyZVNwcml0ZShjYW52YXMsIGN0eCwgd29yZHMsIGkpO1xuICAgICAgICAgICAgY29uc3Qgd29yZCA9IHJlZ2lvbldvcmRzW2ldO1xuICAgICAgICAgICAgd29yZC54ID0gY2VudGVyWzBdLCB3b3JkLnkgPSBjZW50ZXJbMV0sIHdvcmQuaGFzVGV4dCAmJiB3b3JkLnNwcml0ZSAmJiBwbGFjZShib2FyZCwgd29yZCwgbWF4UiwgcmF0aW8sIHNpemUsIGJvYXJkU2l6ZSwgc3RlcEZhY3RvcikgJiYgKHdvcmQuaGFzUGxhY2VkID0gITApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IF8gPSAwOyBfIDwgbGF5b3V0Q29uZmlnLnRleHRMYXlvdXRUaW1lczsgXysrKSB7XG4gICAgICAgIGNvbnN0IGZhaWxlZFdvcmRzID0gd29yZHMuZmlsdGVyKCh3b3JkID0+ICh3b3JkLmhhc1BsYWNlZCB8fCAod29yZC5oYXNUZXh0ID0gITEsIFxuICAgICAgICB3b3JkLnNwcml0ZSA9IG51bGwsIHdvcmQuZm9udFNpemUgPSBNYXRoLm1heCh+fih3b3JkLmZvbnRTaXplICogbGF5b3V0Q29uZmlnLmZvbnRTaXplU2hyaW5rRmFjdG9yKSwgbGF5b3V0Q29uZmlnLm1pbkZvbnRTaXplKSksIFxuICAgICAgICAhd29yZC5oYXNQbGFjZWQpKSk7XG4gICAgICAgIGlmICgwID09PSBmYWlsZWRXb3Jkcy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZhaWxlZFdvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB3b3JkID0gZmFpbGVkV29yZHNbaV07XG4gICAgICAgICAgICBtZWFzdXJlU3ByaXRlKGNhbnZhcywgY3R4LCBmYWlsZWRXb3JkcywgaSksIHdvcmQueCA9IHNoYXBlQ2VudGVyWzBdLCB3b3JkLnkgPSBzaGFwZUNlbnRlclsxXSwgXG4gICAgICAgICAgICB3b3JkLmhhc1RleHQgJiYgcGxhY2UoYm9hcmQsIHdvcmQsIHNoYXBlTWF4Uiwgc2hhcGVSYXRpbywgc2l6ZSwgYm9hcmRTaXplLCBzdGVwRmFjdG9yKSAmJiAod29yZC5oYXNQbGFjZWQgPSAhMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGF5b3V0Q29uZmlnLmJvYXJkID0gYm9hcmQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsYXlvdXRTZWxmU2hyaW5rKHdvcmRzLCBsYXlvdXRDb25maWcsIHNlZ21lbnRhdGlvbk91dHB1dCkge1xuICAgIGNvbnN0IHtzaXplOiBzaXplLCBzdGVwRmFjdG9yOiBzdGVwRmFjdG9yfSA9IGxheW91dENvbmZpZywge3NlZ21lbnRhdGlvbjoge3JlZ2lvbnM6IHJlZ2lvbnN9LCB0ZW1wQ2FudmFzOiBjYW52YXMsIGJvYXJkU2l6ZTogYm9hcmRTaXplfSA9IHNlZ21lbnRhdGlvbk91dHB1dCwgYm9hcmQgPSBpbml0Qm9hcmRXaXRoU2hhcGUoc2VnbWVudGF0aW9uT3V0cHV0KSwgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogITBcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IHJlZ2lvbiBvZiByZWdpb25zKSB7XG4gICAgICAgIGNvbnN0IHt3b3JkczogcmVnaW9uV29yZHMsIGNlbnRlcjogY2VudGVyLCBtYXhSOiBtYXhSLCByYXRpbzogcmF0aW99ID0gcmVnaW9uO1xuICAgICAgICBsZXQgZm9udEZhY3RvciA9IDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVnaW9uV29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG1lYXN1cmVTcHJpdGUoY2FudmFzLCBjdHgsIHdvcmRzLCBpKTtcbiAgICAgICAgICAgIGNvbnN0IHdvcmQgPSByZWdpb25Xb3Jkc1tpXTtcbiAgICAgICAgICAgIGlmICh3b3JkLnggPSBjZW50ZXJbMF0sIHdvcmQueSA9IGNlbnRlclsxXSwgd29yZC5oYXNUZXh0ICYmIHdvcmQuc3ByaXRlICYmIHBsYWNlKGJvYXJkLCB3b3JkLCBtYXhSLCByYXRpbywgc2l6ZSwgYm9hcmRTaXplLCBzdGVwRmFjdG9yKSkgd29yZC5oYXNQbGFjZWQgPSAhMDsgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9udEZhY3RvciAqPSBsYXlvdXRDb25maWcuZm9udFNpemVTaHJpbmtGYWN0b3I7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCByZWdpb25Xb3Jkcy5sZW5ndGg7IGorKykgd29yZC5oYXNUZXh0ID0gITEsIHdvcmQuc3ByaXRlID0gbnVsbCwgXG4gICAgICAgICAgICAgICAgd29yZC5mb250U2l6ZSA9IE1hdGgubWF4KH5+KHdvcmQuZm9udFNpemUgKiBmb250RmFjdG9yKSwgbGF5b3V0Q29uZmlnLm1pbkZvbnRTaXplKTtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGF5b3V0Q29uZmlnLmJvYXJkID0gYm9hcmQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsYXlvdXRHbG9iYWxTaHJpbmsod29yZHMsIGxheW91dENvbmZpZywgc2VnbWVudGF0aW9uT3V0cHV0KSB7XG4gICAgY29uc3Qge3N0ZXBGYWN0b3I6IHN0ZXBGYWN0b3IsIGltcG9ydGFudFdvcmRDb3VudDogaW1wb3J0YW50V29yZENvdW50LCBnbG9iYWxTaGlua0xpbWl0OiBnbG9iYWxTaGlua0xpbWl0fSA9IGxheW91dENvbmZpZywge3NpemU6IHNpemUsIHNlZ21lbnRhdGlvbjoge3JlZ2lvbnM6IHJlZ2lvbnN9LCB0ZW1wQ2FudmFzOiBjYW52YXMsIGJvYXJkU2l6ZTogYm9hcmRTaXplLCBzaGFwZUNlbnRlcjogc2hhcGVDZW50ZXIsIHNoYXBlTWF4Ujogc2hhcGVNYXhSLCBzaGFwZVJhdGlvOiBzaGFwZVJhdGlvfSA9IHNlZ21lbnRhdGlvbk91dHB1dCwgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogITBcbiAgICB9KSwgYm9hcmRPcmlnaW4gPSBpbml0Qm9hcmRXaXRoU2hhcGUoc2VnbWVudGF0aW9uT3V0cHV0KTtcbiAgICBsZXQgYm9hcmQgPSBib2FyZE9yaWdpbi5zbGljZSgwKTtcbiAgICBjb25zdCBmb250RmFjdG9yID0gbGF5b3V0Q29uZmlnLmZvbnRTaXplU2hyaW5rRmFjdG9yO1xuICAgIGxldCBpZCA9IG51bGwsIGlkSW50aWFsRmFjdG9yID0gMSwgZ2xvYmFsU2hpbmtGYWN0b3IgPSAxO1xuICAgIGNvbnN0IGltcG9ydGFudENvdW50ID0gaW1wb3J0YW50V29yZENvdW50O1xuICAgIGxldCB3ZWlnaHRTdGQgPSAwO1xuICAgIGlmICh3b3Jkcy5sZW5ndGggPiBpbXBvcnRhbnRDb3VudCkge1xuICAgICAgICB3ZWlnaHRTdGQgPSB3b3Jkcy5zb3J0KCgod29yZDAsIHdvcmQxKSA9PiB3b3JkMS53ZWlnaHQgLSB3b3JkMC53ZWlnaHQpKVtpbXBvcnRhbnRDb3VudF0ud2VpZ2h0O1xuICAgIH1cbiAgICBmb3IgKGxldCBrID0gMDsgayA8IHJlZ2lvbnMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgY29uc3QgcmVnaW9uID0gcmVnaW9uc1trXSwge3dvcmRzOiByZWdpb25Xb3JkcywgY2VudGVyOiBjZW50ZXIsIG1heFI6IG1heFIsIHJhdGlvOiByYXRpb30gPSByZWdpb247XG4gICAgICAgIGxldCByZXN0YXJ0VGFnID0gITE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVnaW9uV29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG1lYXN1cmVTcHJpdGUoY2FudmFzLCBjdHgsIHdvcmRzLCBpKTtcbiAgICAgICAgICAgIGNvbnN0IHdvcmQgPSByZWdpb25Xb3Jkc1tpXTtcbiAgICAgICAgICAgIGlmICh3b3JkLnggPSBjZW50ZXJbMF0sIHdvcmQueSA9IGNlbnRlclsxXSwgIXdvcmQuc2tpcCAmJiB3b3JkLmhhc1RleHQgJiYgd29yZC5zcHJpdGUgJiYgcGxhY2UoYm9hcmQsIHdvcmQsIG1heFIsIHJhdGlvLCBzaXplLCBib2FyZFNpemUsIHN0ZXBGYWN0b3IpKSB3b3JkLmhhc1BsYWNlZCA9ICEwOyBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXdvcmQuc2tpcCAmJiB3b3JkLndlaWdodCA+IHdlaWdodFN0ZCAmJiBnbG9iYWxTaGlua0ZhY3RvciA+IGdsb2JhbFNoaW5rTGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd29yZElkID0gd29yZC5kYXR1bVtTeW1ib2wuZm9yKFwidkdyYW1tYXJfaWRcIildO1xuICAgICAgICAgICAgICAgICAgICB3b3JkSWQgIT09IGlkICYmIChpZCA9IHdvcmRJZCwgaWRJbnRpYWxGYWN0b3IgPSBnbG9iYWxTaGlua0ZhY3RvciksIGdsb2JhbFNoaW5rRmFjdG9yICo9IGZvbnRGYWN0b3IsIFxuICAgICAgICAgICAgICAgICAgICB3b3Jkcy5mb3JFYWNoKCh3b3JkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmQuaGFzVGV4dCA9ICExLCB3b3JkLnNwcml0ZSA9IG51bGwsIHdvcmQuZm9udFNpemUgPSB3b3JkLmZvbnRTaXplICogZm9udEZhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgfSkpLCBib2FyZCA9IGJvYXJkT3JpZ2luLnNsaWNlKDApLCByZXN0YXJ0VGFnID0gITA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXdvcmQuc2tpcCAmJiB3b3JkLmRhdHVtW1N5bWJvbC5mb3IoXCJ2R3JhbW1hcl9pZFwiKV0gPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmRzLmZvckVhY2goKHdvcmQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgd29yZC5oYXNUZXh0ID0gITEsIHdvcmQuc3ByaXRlID0gbnVsbCwgd29yZC5mb250U2l6ZSA9IHdvcmQuZm9udFNpemUgLyBnbG9iYWxTaGlua0ZhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgfSkpLCB3b3JkLnNraXAgPSAhMCwgZ2xvYmFsU2hpbmtGYWN0b3IgPSBpZEludGlhbEZhY3RvciwgaWQgPSBudWxsLCBib2FyZCA9IGJvYXJkT3JpZ2luLnNsaWNlKDApLCBcbiAgICAgICAgICAgICAgICAgICAgcmVzdGFydFRhZyA9ICEwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdGFydFRhZyAmJiAoayA9IC0xKTtcbiAgICB9XG4gICAgZm9yIChsZXQgXyA9IDA7IF8gPCBsYXlvdXRDb25maWcudGV4dExheW91dFRpbWVzOyBfKyspIHtcbiAgICAgICAgY29uc3QgZmFpbGVkV29yZHMgPSB3b3Jkcy5maWx0ZXIoKHdvcmQgPT4gKHdvcmQuaGFzUGxhY2VkIHx8ICh3b3JkLmhhc1RleHQgPSAhMSwgXG4gICAgICAgIHdvcmQuc3ByaXRlID0gbnVsbCwgd29yZC5mb250U2l6ZSA9IE1hdGgubWF4KH5+KHdvcmQuZm9udFNpemUgKiBsYXlvdXRDb25maWcuZm9udFNpemVTaHJpbmtGYWN0b3IpLCBsYXlvdXRDb25maWcubWluRm9udFNpemUpKSwgXG4gICAgICAgICF3b3JkLmhhc1BsYWNlZCkpKTtcbiAgICAgICAgaWYgKDAgPT09IGZhaWxlZFdvcmRzLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmFpbGVkV29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHdvcmQgPSBmYWlsZWRXb3Jkc1tpXTtcbiAgICAgICAgICAgIG1lYXN1cmVTcHJpdGUoY2FudmFzLCBjdHgsIGZhaWxlZFdvcmRzLCBpKSwgd29yZC54ID0gc2hhcGVDZW50ZXJbMF0sIHdvcmQueSA9IHNoYXBlQ2VudGVyWzFdLCBcbiAgICAgICAgICAgIHdvcmQuaGFzVGV4dCAmJiBwbGFjZShib2FyZCwgd29yZCwgc2hhcGVNYXhSLCBzaGFwZVJhdGlvLCBzaXplLCBib2FyZFNpemUsIHN0ZXBGYWN0b3IpICYmICh3b3JkLmhhc1BsYWNlZCA9ICEwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsYXlvdXRDb25maWcuYm9hcmQgPSBib2FyZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxheW91dFNlbGZFbmxhcmdlKHdvcmRzLCBsYXlvdXRDb25maWcsIHNlZ21lbnRhdGlvbk91dHB1dCkge1xuICAgIGNvbnN0IHtzaXplOiBzaXplLCBzdGVwRmFjdG9yOiBzdGVwRmFjdG9yLCBpbXBvcnRhbnRXb3JkQ291bnQ6IGltcG9ydGFudFdvcmRDb3VudH0gPSBsYXlvdXRDb25maWcsIHtzZWdtZW50YXRpb246IHtyZWdpb25zOiByZWdpb25zfSwgdGVtcENhbnZhczogY2FudmFzLCBib2FyZFNpemU6IGJvYXJkU2l6ZSwgc2hhcGVDZW50ZXI6IHNoYXBlQ2VudGVyLCBzaGFwZU1heFI6IHNoYXBlTWF4Uiwgc2hhcGVSYXRpbzogc2hhcGVSYXRpb30gPSBzZWdtZW50YXRpb25PdXRwdXQsIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6ICEwXG4gICAgfSksIGJvYXJkT3JpZ2luID0gaW5pdEJvYXJkV2l0aFNoYXBlKHNlZ21lbnRhdGlvbk91dHB1dCk7XG4gICAgbGV0IGJvYXJkID0gYm9hcmRPcmlnaW4uc2xpY2UoMCk7XG4gICAgY29uc3QgZm9udEZhY3RvciA9IGxheW91dENvbmZpZy5mb250U2l6ZUVubGFyZ2VGYWN0b3IsIGltcG9ydGFudENvdW50ID0gTWF0aC5taW4oaW1wb3J0YW50V29yZENvdW50LCB3b3Jkcy5sZW5ndGgpO1xuICAgIGxldCB3ZWlnaHRTdGQgPSAwO1xuICAgIGlmICh3b3Jkcy5sZW5ndGggPiBpbXBvcnRhbnRDb3VudCkge1xuICAgICAgICB3ZWlnaHRTdGQgPSB3b3Jkcy5zb3J0KCgod29yZDAsIHdvcmQxKSA9PiB3b3JkMS53ZWlnaHQgLSB3b3JkMC53ZWlnaHQpKVtpbXBvcnRhbnRDb3VudCAtIDFdLndlaWdodDtcbiAgICB9XG4gICAgbGV0IGltcG9ydGFudFdvcmRTdWNjZXNzZWROdW0gPSAwLCBnbG9iYWxFbmxhcmdlRmFjdG9yID0gMSwgbGF5b3V0RmluaXNoID0gITE7XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCByZWdpb25zLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGNvbnN0IHJlZ2lvbiA9IHJlZ2lvbnNba10sIHt3b3JkczogcmVnaW9uV29yZHMsIGNlbnRlcjogY2VudGVyLCBtYXhSOiBtYXhSLCByYXRpbzogcmF0aW99ID0gcmVnaW9uO1xuICAgICAgICBsZXQgcmVzdGFydFRhZyA9ICExO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlZ2lvbldvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBtZWFzdXJlU3ByaXRlKGNhbnZhcywgY3R4LCB3b3JkcywgaSk7XG4gICAgICAgICAgICBjb25zdCB3b3JkID0gcmVnaW9uV29yZHNbaV07XG4gICAgICAgICAgICBpZiAod29yZC54ID0gY2VudGVyWzBdLCB3b3JkLnkgPSBjZW50ZXJbMV0sIHdvcmQuaGFzVGV4dCAmJiB3b3JkLnNwcml0ZSAmJiBwbGFjZShib2FyZCwgd29yZCwgbWF4UiwgcmF0aW8sIHNpemUsIGJvYXJkU2l6ZSwgc3RlcEZhY3RvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAod29yZC5oYXNQbGFjZWQgPSAhMCwgd29yZC53ZWlnaHQgPj0gd2VpZ2h0U3RkICYmIGltcG9ydGFudFdvcmRTdWNjZXNzZWROdW0rKywgXG4gICAgICAgICAgICAgICAgaW1wb3J0YW50V29yZFN1Y2Nlc3NlZE51bSA+PSBpbXBvcnRhbnRDb3VudCAmJiAhbGF5b3V0RmluaXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbEVubGFyZ2VGYWN0b3IgKj0gZm9udEZhY3Rvciwgd29yZHMuZm9yRWFjaCgod29yZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JkLmhhc1RleHQgPSAhMSwgd29yZC5zcHJpdGUgPSBudWxsLCB3b3JkLmZvbnRTaXplID0gd29yZC5mb250U2l6ZSAqIGZvbnRGYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIH0pKSwgYm9hcmQgPSBib2FyZE9yaWdpbi5zbGljZSgwKSwgcmVzdGFydFRhZyA9ICEwLCBpbXBvcnRhbnRXb3JkU3VjY2Vzc2VkTnVtID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAod29yZC53ZWlnaHQgPj0gd2VpZ2h0U3RkICYmIGdsb2JhbEVubGFyZ2VGYWN0b3IgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmRzLmZvckVhY2goKHdvcmQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgd29yZC5oYXNUZXh0ID0gITEsIHdvcmQuc3ByaXRlID0gbnVsbCwgd29yZC5mb250U2l6ZSA9IHdvcmQuZm9udFNpemUgLyBmb250RmFjdG9yO1xuICAgICAgICAgICAgICAgICAgICB9KSksIGdsb2JhbEVubGFyZ2VGYWN0b3IgLz0gZm9udEZhY3RvciwgbGF5b3V0RmluaXNoID0gITAsIGJvYXJkID0gYm9hcmRPcmlnaW4uc2xpY2UoMCksIFxuICAgICAgICAgICAgICAgICAgICByZXN0YXJ0VGFnID0gITA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAod29yZC53ZWlnaHQgPj0gd2VpZ2h0U3RkKSByZXR1cm4gbGF5b3V0R2xvYmFsU2hyaW5rKHdvcmRzLCBsYXlvdXRDb25maWcsIHNlZ21lbnRhdGlvbk91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdGFydFRhZyAmJiAoayA9IC0xKTtcbiAgICB9XG4gICAgZm9yIChsZXQgXyA9IDA7IF8gPCBsYXlvdXRDb25maWcudGV4dExheW91dFRpbWVzOyBfKyspIHtcbiAgICAgICAgY29uc3QgZmFpbGVkV29yZHMgPSB3b3Jkcy5maWx0ZXIoKHdvcmQgPT4gKHdvcmQuaGFzUGxhY2VkIHx8ICh3b3JkLmhhc1RleHQgPSAhMSwgXG4gICAgICAgIHdvcmQuc3ByaXRlID0gbnVsbCwgd29yZC5mb250U2l6ZSA9IE1hdGgubWF4KH5+KHdvcmQuZm9udFNpemUgKiBsYXlvdXRDb25maWcuZm9udFNpemVTaHJpbmtGYWN0b3IpLCBsYXlvdXRDb25maWcubWluRm9udFNpemUpKSwgXG4gICAgICAgICF3b3JkLmhhc1BsYWNlZCkpKTtcbiAgICAgICAgaWYgKDAgPT09IGZhaWxlZFdvcmRzLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmFpbGVkV29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHdvcmQgPSBmYWlsZWRXb3Jkc1tpXTtcbiAgICAgICAgICAgIG1lYXN1cmVTcHJpdGUoY2FudmFzLCBjdHgsIGZhaWxlZFdvcmRzLCBpKSwgd29yZC54ID0gc2hhcGVDZW50ZXJbMF0sIHdvcmQueSA9IHNoYXBlQ2VudGVyWzFdLCBcbiAgICAgICAgICAgIHdvcmQuaGFzVGV4dCAmJiBwbGFjZShib2FyZCwgd29yZCwgc2hhcGVNYXhSLCBzaGFwZVJhdGlvLCBzaXplLCBib2FyZFNpemUsIHN0ZXBGYWN0b3IpICYmICh3b3JkLmhhc1BsYWNlZCA9ICEwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsYXlvdXRDb25maWcuYm9hcmQgPSBib2FyZDtcbn1cblxuZnVuY3Rpb24gcGxhY2UoYm9hcmQsIHdvcmQsIG1heFIsIHJhdGlvLCBzaXplLCBib2FyZFNpemUsIHN0ZXBGYWN0b3IpIHtcbiAgICBjb25zdCBzdGFydFggPSB3b3JkLngsIHN0YXJ0WSA9IHdvcmQueSwgc3BpcmFsID0gYXJjaGltZWRlYW5TcGlyYWwocmF0aW8pLCBkdCA9IDEgKiBzdGVwRmFjdG9yO1xuICAgIGxldCBkeGR5LCBkeCwgZHksIHQgPSAtZHQ7XG4gICAgZm9yICg7ZHhkeSA9IHNwaXJhbCh0ICs9IGR0KTsgKSB7XG4gICAgICAgIGNvbnN0IHt3b3JkU2l6ZTogd29yZFNpemUsIGJvdW5kczoge2RUb3A6IGRUb3AsIGRCb3R0b206IGRCb3R0b20sIGRMZWZ0OiBkTGVmdCwgZFJpZ2h0OiBkUmlnaHR9fSA9IHdvcmQ7XG4gICAgICAgIGlmIChkeCA9IGR4ZHlbMF0sIGR5ID0gZHhkeVsxXSwgTWF0aC5taW4oTWF0aC5hYnMoZHgpLCBNYXRoLmFicyhkeSkpID49IG1heFIpIGJyZWFrO1xuICAgICAgICBpZiAod29yZC54ID0gfn4oc3RhcnRYICsgZHgpLCB3b3JkLnkgPSB+fihzdGFydFkgKyBkeSksICEod29yZC54IC0gZExlZnQgPCAwIHx8IHdvcmQueCArIGRSaWdodCA+IHNpemVbMF0gfHwgd29yZC55IC0gZFRvcCA8IDAgfHwgd29yZC55ICsgZEJvdHRvbSA+IHNpemVbMV0gfHwgaXNDb2xsaWRlV2l0aEJvYXJkKHdvcmQsIGJvYXJkLCBib2FyZFNpemUpKSkgcmV0dXJuIHBsYWNlV29yZE9uQm9hcmQod29yZCwgYm9hcmQsIGJvYXJkU2l6ZSksIFxuICAgICAgICAhMDtcbiAgICB9XG4gICAgcmV0dXJuICExO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGxhY2VXb3JkT25Cb2FyZCh3b3JkLCBib2FyZCwgYm9hcmRTaXplKSB7XG4gICAgY29uc3Qge3dvcmRTaXplOiB3b3JkU2l6ZX0gPSB3b3JkLCBzcHJpdGUgPSB3b3JkLnNwcml0ZSwgdyA9IHdvcmRTaXplWzBdID4+IDUsIHN3ID0gYm9hcmRTaXplWzBdID4+IDUsIGx4ID0gd29yZC54IC0gKHcgPDwgNCksIHN4ID0gbHggJSAzMiwgbXN4ID0gMzIgLSBzeCwgaCA9IHdvcmRTaXplWzFdO1xuICAgIGxldCBsYXN0LCB4ID0gKHdvcmQueSAtICh3b3JkU2l6ZVsxXSA+PiAxKSkgKiBzdyArIChseCA+PiA1KTtcbiAgICBpZiAoMCA9PT0gc3gpIGZvciAobGV0IGogPSAwOyBqIDwgaDsgaisrKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdzsgaSsrKSBib2FyZFt4ICsgaV0gfD0gc3ByaXRlW2ogKiB3ICsgaV07XG4gICAgICAgIHggKz0gc3c7XG4gICAgfSBlbHNlIGZvciAobGV0IGogPSAwOyBqIDwgaDsgaisrKSB7XG4gICAgICAgIGxhc3QgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB3OyBpKyspIGJvYXJkW3ggKyBpXSB8PSBsYXN0IDw8IG1zeCB8IChpIDwgdyA/IChsYXN0ID0gc3ByaXRlW2ogKiB3ICsgaV0pID4+PiBzeCA6IDApO1xuICAgICAgICB4ICs9IHN3O1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29sbGlkZVdpdGhCb2FyZCh3b3JkLCBib2FyZCwgYm9hcmRTaXplKSB7XG4gICAgY29uc3Qge3Nwcml0ZTogc3ByaXRlLCB3b3JkU2l6ZTogd29yZFNpemV9ID0gd29yZCwgc3cgPSBib2FyZFNpemVbMF0gPj4gNSwgdyA9IHdvcmRTaXplWzBdID4+IDUsIGx4ID0gd29yZC54IC0gKHcgPDwgNCksIHN4ID0gbHggJSAzMiwgbXN4ID0gMzIgLSBzeCwgaCA9IHdvcmRTaXplWzFdO1xuICAgIGxldCBsYXN0LCB4ID0gKHdvcmQueSAtICh3b3JkU2l6ZVsxXSA+PiAxKSkgKiBzdyArIChseCA+PiA1KTtcbiAgICBpZiAoMCA9PT0gc3gpIGZvciAobGV0IGogPSAwOyBqIDwgaDsgaisrKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdzsgaSsrKSBpZiAoYm9hcmRbeCArIGldICYgc3ByaXRlW2ogKiB3ICsgaV0pIHJldHVybiAhMDtcbiAgICAgICAgeCArPSBzdztcbiAgICB9IGVsc2UgZm9yIChsZXQgaiA9IDA7IGogPCBoOyBqKyspIHtcbiAgICAgICAgbGFzdCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHc7IGkrKykgaWYgKChsYXN0IDw8IG1zeCB8IChpIDwgdyA/IChsYXN0ID0gc3ByaXRlW2ogKiB3ICsgaV0pID4+PiBzeCA6IDApKSAmIGJvYXJkW3ggKyBpXSkgcmV0dXJuICEwO1xuICAgICAgICB4ICs9IHN3O1xuICAgIH1cbiAgICByZXR1cm4gITE7XG59XG5cbmZ1bmN0aW9uIGFyY2hpbWVkZWFuU3BpcmFsKHJhdGlvKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIFsgcmF0aW8gKiAodCAqPSAuMSkgKiBNYXRoLmNvcyh0KSwgdCAqIE1hdGguc2luKHQpIF07XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lYXN1cmVTcHJpdGUoY2FudmFzLCBjdHgsIHdvcmRzLCB3aSkge1xuICAgIGlmICh3b3Jkc1t3aV0uc3ByaXRlIHx8IDAgPT09IHdvcmRzW3dpXS5mb250U2l6ZSkgcmV0dXJuO1xuICAgIGNvbnN0IGN3ID0gMjA0OCwgcmFkaWFucyA9IE1hdGguUEkgLyAxODAsIG4gPSB3b3Jkcy5sZW5ndGg7XG4gICAgY2FudmFzLndpZHRoID0gY3csIGNhbnZhcy5oZWlnaHQgPSAyMDQ4LCBjdHguY2xlYXJSZWN0KDAsIDAsIGN3LCAyMDQ4KSwgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgbGV0IHdvcmRXLCB3b3JkSCwgeCA9IDAsIHkgPSAwLCBtYXhIZWlnaHQgPSAwLCB5TWF4ID0gMDtcbiAgICBjb25zdCB3aURpc3QgPSB3aTtcbiAgICBmb3IgKC0td2k7ICsrd2kgPCBuOyApIHtcbiAgICAgICAgY29uc3Qgd29yZCA9IHdvcmRzW3dpXSwgZm9udFNpemUgPSBNYXRoLm1heCh3b3JkLmZvbnRTaXplLCAyKTtcbiAgICAgICAgaWYgKGN0eC5zYXZlKCksIGN0eC5mb250ID0gd29yZC5mb250U3R5bGUgKyBcIiBcIiArIHdvcmQuZm9udFdlaWdodCArIFwiIFwiICsgZm9udFNpemUgKyBcInB4IFwiICsgd29yZC5mb250RmFtaWx5LCBcbiAgICAgICAgd29yZFcgPSBjdHgubWVhc3VyZVRleHQod29yZC50ZXh0ICsgXCJtXCIpLndpZHRoICsgMiAqIHdvcmQucGFkZGluZywgd29yZEggPSAyICogZm9udFNpemUgKyAyICogd29yZC5wYWRkaW5nLCBcbiAgICAgICAgMCAhPT0gd29yZC5yb3RhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNyID0gTWF0aC5zaW4od29yZC5yb3RhdGUgKiByYWRpYW5zKSwgY3IgPSBNYXRoLmNvcyh3b3JkLnJvdGF0ZSAqIHJhZGlhbnMpLCB3Y3IgPSB3b3JkVyAqIGNyLCB3c3IgPSB3b3JkVyAqIHNyLCBoY3IgPSB3b3JkSCAqIGNyLCBoc3IgPSB3b3JkSCAqIHNyO1xuICAgICAgICAgICAgd29yZFcgPSBNYXRoLm1heChNYXRoLmFicyh3Y3IgKyBoc3IpLCBNYXRoLmFicyh3Y3IgLSBoc3IpKSwgd29yZEggPSB+fk1hdGgubWF4KE1hdGguYWJzKHdzciArIGhjciksIE1hdGguYWJzKHdzciAtIGhjcikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JkVyA9IHdvcmRXICsgMzEgPj4gNSA8PCA1LCB3b3JkSCA9IE1hdGguY2VpbCh3b3JkSCksIHdvcmRIID4gbWF4SGVpZ2h0ICYmIChtYXhIZWlnaHQgPSB3b3JkSCksIFxuICAgICAgICB4ICsgd29yZFcgPj0gY3cgJiYgKHggPSAwLCB5ICs9IG1heEhlaWdodCwgbWF4SGVpZ2h0ID0gd29yZEgpLCB5ICsgd29yZEggPj0gMjA0OCkge1xuICAgICAgICAgICAgaWYgKDAgPT09IHkpIHtcbiAgICAgICAgICAgICAgICB3b3JkLmhhc1RleHQgPSAhMTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHkgKyB3b3JkSCA+PSB5TWF4ICYmICh5TWF4ID0geSArIHdvcmRIKSwgY3R4LnRyYW5zbGF0ZSh4ICsgKHdvcmRXID4+IDEpLCB5ICsgKHdvcmRIID4+IDEpKSwgXG4gICAgICAgIDAgIT09IHdvcmQucm90YXRlICYmIGN0eC5yb3RhdGUod29yZC5yb3RhdGUgKiByYWRpYW5zKSwgY3R4LmZpbGxUZXh0KHdvcmQudGV4dCwgMCwgMCksIFxuICAgICAgICB3b3JkLnBhZGRpbmcgJiYgKGN0eC5saW5lV2lkdGggPSAyICogd29yZC5wYWRkaW5nLCBjdHguc3Ryb2tlVGV4dCh3b3JkLnRleHQsIDAsIDApKSwgXG4gICAgICAgIGN0eC5yZXN0b3JlKCksIHdvcmQuTFQgPSBbIHgsIHkgXSwgd29yZC53b3JkU2l6ZSA9IFsgd29yZFcsIHdvcmRIIF0sIHdvcmQuaGFzVGV4dCA9ICEwLCBcbiAgICAgICAgeCArPSB3b3JkVztcbiAgICB9XG4gICAgaWYgKDAgPT09IHlNYXgpIHJldHVybjtcbiAgICBjb25zdCBwaXhlbHMgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGN3LCB5TWF4KS5kYXRhO1xuICAgIGxldCBpLCBqO1xuICAgIGZvciAoOy0td2kgPj0gd2lEaXN0OyApIHtcbiAgICAgICAgY29uc3Qgd29yZCA9IHdvcmRzW3dpXTtcbiAgICAgICAgaWYgKCF3b3JkLmhhc1RleHQpIHtcbiAgICAgICAgICAgIHdvcmQuYm91bmRzID0ge1xuICAgICAgICAgICAgICAgIGRUb3A6IDEgLyAwLFxuICAgICAgICAgICAgICAgIGRCb3R0b206IC0xIC8gMCxcbiAgICAgICAgICAgICAgICBkTGVmdDogMSAvIDAsXG4gICAgICAgICAgICAgICAgZFJpZ2h0OiAtMSAvIDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7TFQ6IExUID0gWyAwLCAwIF0sIHdvcmRTaXplOiB3b3JkU2l6ZX0gPSB3b3JkO1xuICAgICAgICBbeCwgeV0gPSBMVDtcbiAgICAgICAgY29uc3QgdzMyID0gd29yZFNpemVbMF0gPj4gNSwgc3ByaXRlID0gbmV3IEFycmF5KHczMiAqIHdvcmRTaXplWzFdKS5maWxsKDApO1xuICAgICAgICBsZXQgW2RUb3AsIGRCb3R0b20sIGRMZWZ0LCBkUmlnaHRdID0gWyAxIC8gMCwgLTEgLyAwLCAxIC8gMCwgLTEgLyAwIF07XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCB3b3JkU2l6ZVsxXTsgaisrKSB7XG4gICAgICAgICAgICBsZXQgc2VlbjtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB3b3JkU2l6ZVswXTsgaSsrKSBpZiAocGl4ZWxzWzQgKiAoKHkgKyBqKSAqIGN3ICsgKHggKyBpKSkgKyAzXSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gMSA8PCAzMSAtIGkgJSAzMjtcbiAgICAgICAgICAgICAgICBzcHJpdGVbdzMyICogaiArIChpID4+IDUpXSB8PSBtLCBpIDwgZExlZnQgJiYgKGRMZWZ0ID0gaSksIGkgPiBkUmlnaHQgJiYgKGRSaWdodCA9IGkpLCBcbiAgICAgICAgICAgICAgICBzZWVuIHw9IG07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWVuICYmIChqIDwgZFRvcCAmJiAoZFRvcCA9IGopLCBqID4gZEJvdHRvbSAmJiAoZEJvdHRvbSA9IGopKTtcbiAgICAgICAgfVxuICAgICAgICB3b3JkLmJvdW5kcyA9IHtcbiAgICAgICAgICAgIGRUb3A6ICh3b3JkU2l6ZVsxXSA+PiAxKSAtIGRUb3AsXG4gICAgICAgICAgICBkQm90dG9tOiBkQm90dG9tIC0gKHdvcmRTaXplWzFdID4+IDEpLFxuICAgICAgICAgICAgZExlZnQ6ICh3b3JkU2l6ZVswXSA+PiAxKSAtIGRMZWZ0LFxuICAgICAgICAgICAgZFJpZ2h0OiBkUmlnaHQgLSAod29yZFNpemVbMF0gPj4gMSlcbiAgICAgICAgfSwgd29yZC5zcHJpdGUgPSBzcHJpdGUsIGRlbGV0ZSB3b3JkLkxUO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaW5pdEJvYXJkV2l0aFNoYXBlKHNlZ21lbnRhdGlvbk91dHB1dCkge1xuICAgIGNvbnN0IHtzZWdtZW50YXRpb246IHtsYWJlbHM6IGxhYmVsc30sIGJvYXJkU2l6ZTogYm9hcmRTaXplLCBzaXplOiBzaXplfSA9IHNlZ21lbnRhdGlvbk91dHB1dCwgdzMyID0gYm9hcmRTaXplWzBdID4+IDUsIGJvYXJkID0gbmV3IEFycmF5KHczMiAqIHNpemVbMV0pLmZpbGwoMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplWzFdOyBpKyspIGZvciAobGV0IGogPSAwOyBqIDwgc2l6ZVswXTsgaisrKSB7XG4gICAgICAgIGlmICgwID09PSBsYWJlbHNbaSAqIHNpemVbMF0gKyBqXSkge1xuICAgICAgICAgICAgY29uc3QgbSA9IDEgPDwgMzEgLSBqICUgMzI7XG4gICAgICAgICAgICBib2FyZFt3MzIgKiBpICsgKGogPj4gNSldIHw9IG07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJvYXJkU2l6ZVswXSA+IHNpemVbMF0pIHtcbiAgICAgICAgY29uc3QgbSA9ICgxIDw8IGJvYXJkU2l6ZVswXSAtIHNpemVbMF0pIC0gMTtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBzaXplWzFdOyB5KyspIHtcbiAgICAgICAgICAgIGJvYXJkW3czMiAqIHkgKyB3MzIgLSAxXSB8PSBtO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBib2FyZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmRsZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.14.13/node_modules/@visactor/vgrammar-wordcloud-shape/es/wordle.js\n");

/***/ })

};
;